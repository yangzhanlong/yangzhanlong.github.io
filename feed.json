{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "AndroidGuide",
  "home_page_url": "https://yangzhanlong.github.io/",
  "feed_url": "https://yangzhanlong.github.io/feed.json",
  "description": "「Android学习之路」一份涵盖大部分 Android 程序员所需要掌握的核心知识(包括：Java， FrameWork，Kotlin， 音视频， Flutter等)。",
  "items": [
    {
      "title": "GC与调优",
      "url": "https://yangzhanlong.github.io/java/jvm/GC%E4%B8%8E%E8%B0%83%E4%BC%98.html",
      "id": "https://yangzhanlong.github.io/java/jvm/GC%E4%B8%8E%E8%B0%83%E4%BC%98.html",
      "content_html": "<h1 id=\"gc与调优\" tabindex=\"-1\"> GC与调优</h1>\n",
      "date_published": "2022-10-16T13:57:24.000Z",
      "date_modified": "2022-10-16T13:57:24.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Android虚拟机与类加载过程",
      "url": "https://yangzhanlong.github.io/java/jvm/android%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html",
      "id": "https://yangzhanlong.github.io/java/jvm/android%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html",
      "content_html": "<h1 id=\"android虚拟机与类加载过程\" tabindex=\"-1\"> Android虚拟机与类加载过程</h1>\n",
      "date_published": "2022-10-16T13:57:24.000Z",
      "date_modified": "2022-10-16T13:57:24.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "对象分配",
      "url": "https://yangzhanlong.github.io/java/jvm/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D.html",
      "id": "https://yangzhanlong.github.io/java/jvm/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D.html",
      "content_html": "<h1 id=\"对象分配\" tabindex=\"-1\"> 对象分配</h1>\n",
      "date_published": "2022-10-16T13:57:24.000Z",
      "date_modified": "2022-10-16T13:57:24.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "运行时数据区",
      "url": "https://yangzhanlong.github.io/java/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.html",
      "id": "https://yangzhanlong.github.io/java/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.html",
      "content_html": "<h1 id=\"jvm-运行时数据区\" tabindex=\"-1\"> JVM-运行时数据区</h1>\n<p>本文内容:</p>\n<ol>\n<li>JVM介绍&amp;JVM组成部分</li>\n<li>栈指令集架构与寄存器指令集架构</li>\n<li>三种虚拟机介绍</li>\n<li><strong>运行时数据区(重点)</strong></li>\n</ol>\n<h2 id=\"jvm介绍-jvm组成部分\" tabindex=\"-1\"> JVM介绍&amp;JVM组成部分</h2>\n<h3 id=\"java程序的执行过程\" tabindex=\"-1\"> Java程序的执行过程</h3>\n<p>一个 Java 程序，首先经过 <code>javac</code> 编译成 <code>.class</code> 文件，然后 <code>JVM</code> 将其加载到<code>方法区</code>，执行 引擎将会执行这些字节码。\n执行时，会翻译成操作系统相关的函数。<code>JVM</code> 作为 <code>.class</code> 文件的翻译 存在，输入字节码，调用操作系统函数。</p>\n<h3 id=\"什么是jvm\" tabindex=\"-1\"> 什么是JVM</h3>\n<ul>\n<li>\n<p><strong>JVM就是一种规范</strong>，对于汇编的语言规范和处理，而上层的高级语言实际上我们就理解为是一堆的字符串</p>\n</li>\n<li>\n<p>JVM 全称 Java Virtual Machine，也就是 Java 虚拟机。它能识别 .class后缀 的文件，并且能够解析它的指令，最终调用操作系统上的函数，完成我们想要的操作</p>\n</li>\n</ul>\n<div>\n<p>Java程序的执行过程</p>\n<p>Java 文件-&gt;编译器&gt;字节码-&gt;JVM-&gt;机器码</p>\n</div>\n<h3 id=\"jvm与字节码文件\" tabindex=\"-1\"> JVM与字节码文件</h3>\n<ul>\n<li>\n<p>JAVA字节码，指的是JAVA语言编译(通过javac编译.java后缀文件)成的字节码，准确的说任何能在JVM平台上执行的字节码格式都是一样的，所以应该统称为<code>JVM字节码</code></p>\n</li>\n<li>\n<p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</p>\n</li>\n<li>\n<p>JAVA虚拟机与JAVA语言并没有直接联系，他只是特定的二进制文件格式.class文件有所关联， CLASS文件中包含JVM虚拟机指令集(bytecodes)和符号表，还有一些其他辅助信息。</p>\n</li>\n</ul>\n<h3 id=\"jvm组成部分\" tabindex=\"-1\"> JVM组成部分</h3>\n<p>JVM由<code>类加载器</code>，<code>运行时数据区</code>，<code>执行引擎</code>三个部分组成。</p>\n<div>\n<p>JVM组成部分</p>\n<ul>\n<li>类加载器：将编译好的class文件加载到JVM进程中</li>\n<li>运行时数据区：存放系统执行过程中产生的数据</li>\n<li>执行引擎：用来执行汇编及当前进程内所要完成的一些具体内容</li>\n</ul>\n</div>\n<h2 id=\"栈指令集架构与寄存器指令集架构\" tabindex=\"-1\"> 栈指令集架构与寄存器指令集架构</h2>\n<p>JAVA编译器指令是基于栈的指令集架构，而另一种指令是基于寄存器指令集架构。</p>\n<h3 id=\"栈指令集架构与寄存器指令集架构-1\" tabindex=\"-1\"> 栈指令集架构与寄存器指令集架构</h3>\n<ul>\n<li>设计与实现简单，适用于资源受限的系统</li>\n<li>避开寄存器的分配问题，使用0地址指令方式</li>\n<li>指令流中的指令操作过程基于栈，且位数小(8位)，编译器容易实现</li>\n<li>不需要硬件支持，可移植性高</li>\n</ul>\n<img src=\"/assets/icon/栈指令集.png\" style=\"height: 250px; width: 200px\" alt=\"\"/>\n<h3 id=\"栈指令集架构与寄存器指令集架构-2\" tabindex=\"-1\"> 栈指令集架构与寄存器指令集架构</h3>\n<ul>\n<li>x86二进制指令集(16位), android的davlik虚拟机使用的是这种架构</li>\n<li>依赖于硬件，可移植性差</li>\n<li>性能优秀执行高效</li>\n<li>更少时间执行一个操作</li>\n<li>基于寄存器架构的指令一般以1-3个地址指令为主</li>\n</ul>\n<img src=\"/assets/icon/寄存器指令集.png\" style=\"height: 100px; width: 200px\" alt=\"\"/>\n<h2 id=\"三种虚拟机介绍\" tabindex=\"-1\"> 三种虚拟机介绍</h2>\n<h3 id=\"hotspot虚拟机\" tabindex=\"-1\"> Hotspot虚拟机</h3>\n<ul>\n<li>Hotspot虚拟机隶属于sun</li>\n<li>JDK1.3开发Hotspot成为默认虚拟机</li>\n<li>一般面试所有提到的JVM虚拟机都默认指代的是Hotspot虚拟机</li>\n</ul>\n<h3 id=\"dalvik虚拟机-art虚拟机\" tabindex=\"-1\"> Dalvik虚拟机&amp;ART虚拟机</h3>\n<ul>\n<li>Dalvik虚拟机隶属于google</li>\n<li>Dalvik是一款不是JVM的JVM虚拟机。本质上他没有遵循与JVM规范,不能直接运行java Class文件</li>\n<li>他的结构基于寄存器结构，而不是JVM栈架构</li>\n<li>执行的是编译后的Dex文件，执行效率较高, 于Android5.0后被ART替换</li>\n</ul>\n<h2 id=\"运行时数据区\" tabindex=\"-1\"> 运行时数据区</h2>\n<p>JVM整体架构：</p>\n<img src=\"/assets/icon/jvm架构.png\" alt=\"\"/>\n<div>\n<p>运行时数据区</p>\n<ul>\n<li>线程独享：虚拟机栈，本地方法栈，程序计数器</li>\n<li>线程共享：方法区，堆区</li>\n</ul>\n</div>\n<h3 id=\"虚拟机栈\" tabindex=\"-1\"> 虚拟机栈</h3>\n<ul>\n<li>虚拟机栈数据结构： 先进后出(FILO)的数据结构，</li>\n<li>虚拟机栈的作用: 在JVM运行过程中存储当前线程运行方法所需的数据，指令、返回地址。</li>\n<li>虚拟机栈是基于线程的: 哪怕你只有一个 main() 方法，也是以线程的方式运行的。在线程的生命周期中，参与计算的数据会频繁地入栈和出栈，栈的生命周期是和线程一样的。</li>\n<li>虚拟机栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k。</li>\n<li>栈帧：在每个 Java 方法被调用的时候，都会创建一个栈帧，并入栈。一旦方法完成相应的调用，则出栈。</li>\n<li>栈帧大体都包含四个区域：(局部变量表、操作数栈、动态连接、返回地址)</li>\n</ul>\n<p>同时，虚拟机栈这个内存也不是无限大，它有大小限制，默认情况下是1M。\n如果我们不断的往虚拟机栈中入栈帧，但是就是不出栈的话，那么这个虚拟机栈就会溢出。</p>\n<h3 id=\"栈帧\" tabindex=\"-1\"> 栈帧</h3>\n<ol>\n<li>局部变量表</li>\n</ol>\n<p>顾名思义就是局部变量的表，用于存放我们的局部变量的（方法中的变量）。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。</p>\n<p>1.1 局部变量表slot(变量槽)</p>\n<p>slot是局部变量表的基础单位\n在表中，32位类型数据占用一个slot， 64位数据占用2位</p>\n<p>1.2 slot复用问题</p>\n<p>局部变量表中slot是可以服用的，如果一个局部变量过了其他作用域，那么其作用域之后声明的新的局部变量有可能会复用这个solt，以便节省资源。</p>\n<ol start=\"2\">\n<li>操作数栈</li>\n</ol>\n<p>存放java方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的。\n操作数栈本质上是JVM执行引擎的一个工作区，也就是方法在执行，才会对操作数栈进行操作，如果代码不不执行，操作数栈其实就是空的。</p>\n<ol start=\"3\">\n<li>返回地址</li>\n</ol>\n<p>正常返回（调用<code>程序计数器中的地址</code>作为返回）、异常的话（通过<code>异常处理器表</code>&lt;非栈帧中&gt;)</p>\n<p>无论通过那种方式退出，在方法退出后返回到该方法被调用的位置.</p>\n<ol start=\"4\">\n<li>动态连接</li>\n</ol>\n<ul>\n<li>每一个栈帧内部都包含一个执行运行时常量池中该栈帧所述方法的引用。包含这个引用的目的是为 了支持当前方法的代码能够实现动态链接(invokeDynamic指令)</li>\n<li>在Java源文件被编译到字节码文件中是，所有的变量和方法引用都作为符号引用保存在class文件的 <code>常量池</code>里。</li>\n<li>例如：描述一个方法调用另外一个方法是，就是通过常量池中的执行方法符号引用来标识，那么动态 链接的作用就是<strong>为了将这些符号引用转换为调用方法的直接引用</strong></li>\n</ul>\n<h3 id=\"程序计数器\" tabindex=\"-1\"> 程序计数器</h3>\n<ul>\n<li>\n<p>较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响。程序计数器是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。</p>\n</li>\n<li>\n<p>由于 Java 是多线程语言，当执行的线程数量超过 CPU 核数时，线程之间会根据时间片轮询争夺 CPU 资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的 CPU 资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令.</p>\n</li>\n<li>\n<p>因为JVM是虚拟机，内部有完整的指令与执行的一套流程，所以在运行Java方法的时候需要使用程序计数器（记录字节码执行的地址或行号），如果是遇到本地方法（native方法），这个方法不是JVM来具体执行，所以程序计数器不需要记录了，这个是因为在操作系统层面也有一个程序计数器，这个会记录本地代码的执行的地址.</p>\n</li>\n<li>\n<p>另外程序计数器也是JVM中唯一不会OOM(OutOfMemory)的内存区域。</p>\n</li>\n</ul>\n<h3 id=\"本地方法栈\" tabindex=\"-1\"> 本地方法栈</h3>\n<ul>\n<li>\n<p>本地方法栈跟 Java 虚拟机栈的功能类似，Java 虚拟机栈用于管理 Java 函数的调用，而本地方法栈则用于管理本地方法的调用。但本地方法并不是用 Java 实现的，而是由 C 语言实现的(比如Object.hashcode方法)。</p>\n</li>\n<li>\n<p>本地方法栈是和虚拟机栈非常相似的一个区域，它服务的对象是 native 方法。你甚至可以认为虚拟机栈和本地方法栈是同一个区域。\n虚拟机规范无强制规定，各版本虚拟机自由实现 ，HotSpot直接把本地方法栈和虚拟机栈合二为一 。</p>\n</li>\n</ul>\n<h3 id=\"方法区\" tabindex=\"-1\"> 方法区</h3>\n<p>方法区（Method Area）是可供各条线程共享的运行时内存区域。它用于<code>存储运行时常量池</code>、已被虚拟机加载的<code>类型信息</code>、<code>常量</code>、<code>静态变量</code>、及时编译器编译后的代码缓存等\n方法区是JVM对内存的“逻辑划分”，在JDK1.7及之前很多开发者都习惯将方法区称为“永久代”，是因为在HotSpot 虚拟机中，设计人员使用了永久代来实现了 JVM 规范的方法区。在JDK1.8及以后使用了<code>元空间</code>来实现方法区。</p>\n<ul>\n<li><strong>运行时常量池</strong>: 运行时常量池（Runtime Constant Pool）是每一个类或接口的常量池（Constant_Pool）的运行时表示形式，它包括了若干种不同的常量：从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。</li>\n<li>类型信息： 包含类class\\接口interface\\枚举enum\\注解annotation</li>\n<li>方法信息： 执行字节码，本地变量表，操作数栈，动态链接，方法出口，异常表</li>\n</ul>\n<h3 id=\"堆区\" tabindex=\"-1\"> 堆区</h3>\n<ul>\n<li>\n<p>堆是 JVM 上最大的内存区域，我们申请的几乎所有的对象，都是在这里存储的。</p>\n</li>\n<li>\n<p>堆空间一般是程序启动时，就申请了，但是并不一定会全部使用。堆一般设置成可伸缩的.</p>\n</li>\n<li>\n<p>随着对象的频繁创建，堆空间占用的越来越多，就需要不定期的对不再使用的对象进行回收。这个在 Java 中，就叫作 GC（Garbage Collection）。</p>\n</li>\n<li>\n<p>那一个对象创建的时候，到底是在堆上分配，还是在栈上分配呢？这和两个方面有关：对象的类型和在 Java 类中存在的位置。\nJava 的对象可以分为基本数据类型和普通对象。</p>\n</li>\n<li>\n<p>对于普通对象来说，JVM 会首先在堆上创建对象，然后在其他地方使用的其实是它的引用。比如，把这个引用保存在虚拟机栈的局部变量表中。</p>\n</li>\n<li>\n<p>对于基本数据类型来说（byte、short、int、long、float、double、char)，有两种情况。\n<strong>当在方法体内声明了基本数据类型的对象，它就会在栈上直接分配。其他情况，都是在堆上分配。</strong></p>\n</li>\n</ul>\n<h3 id=\"直接内存-堆外内存\" tabindex=\"-1\"> 直接内存(堆外内存)</h3>\n<ul>\n<li>直接内存不是虚拟机运行时数据区的一部分，也不是JAVA 虚拟机规范中定义的内存区域，如果使用了NIO,这块区域会被频繁使用，在java堆内可以用dictiByteBuffer对象 直接引用操作，</li>\n<li>这块内存不受java堆大小限制，但受本机总内存的限制，可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常。</li>\n<li>其他堆外内存，主要是指使用了Unsafe 或者其他 JNI 手段直接直接申请的内存。</li>\n<li>堆外内存的泄漏是非常严重的，它的排查难度高、影响大，甚至会造成主机的死亡</li>\n</ul>\n<h3 id=\"内存溢出问题\" tabindex=\"-1\"> 内存溢出问题</h3>\n<p>内存溢出概念：无法分配内存，可用内存不足，无法完成内存分配\n内存溢出场景：</p>\n<ul>\n<li>栈溢出</li>\n<li>堆溢出</li>\n<li>方法区溢出</li>\n<li>本机直接内存溢出</li>\n</ul>\n<h3 id=\"总结\" tabindex=\"-1\"> 总结</h3>\n<ul>\n<li>\n<p>JVM运行内存的整体流程：</p>\n<p>JVM在操作系统上启动，申请内存，先进行<code>运行时数据区的初始化</code>，然后<code>把类加载到方法区中</code>\n方法的执行和退出过程在内存上的体现上就是<code>虚拟机栈中栈帧的入栈和出栈</code>。\n同时在方法的执行过程中<code>创建的对象一般情况下都是放在堆中</code>，最后堆中的对象也是需要进行<code>垃圾回收清理</code>的</p>\n</li>\n</ul>\n",
      "date_published": "2022-10-16T13:57:24.000Z",
      "date_modified": "2022-10-16T13:57:24.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "指令集解读",
      "url": "https://yangzhanlong.github.io/android/android_vm/%E6%8C%87%E4%BB%A4%E9%9B%86%E8%A7%A3%E8%AF%BB.html",
      "id": "https://yangzhanlong.github.io/android/android_vm/%E6%8C%87%E4%BB%A4%E9%9B%86%E8%A7%A3%E8%AF%BB.html",
      "content_html": "<h1 id=\"指令集解读\" tabindex=\"-1\"> 指令集解读</h1>\n",
      "date_published": "2022-10-04T08:46:29.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "深入Android内存管理",
      "url": "https://yangzhanlong.github.io/android/android_vm/%E6%B7%B1%E5%85%A5Android%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html",
      "id": "https://yangzhanlong.github.io/android/android_vm/%E6%B7%B1%E5%85%A5Android%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html",
      "content_html": "<h1 id=\"深入android内存管理\" tabindex=\"-1\"> 深入Android内存管理</h1>\n",
      "date_published": "2022-10-04T08:46:29.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "类加载与动态字节替换",
      "url": "https://yangzhanlong.github.io/android/android_vm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8A%A8%E6%80%81%E5%AD%97%E8%8A%82%E6%9B%BF%E6%8D%A2.html",
      "id": "https://yangzhanlong.github.io/android/android_vm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8A%A8%E6%80%81%E5%AD%97%E8%8A%82%E6%9B%BF%E6%8D%A2.html",
      "content_html": "<h1 id=\"类加载与动态字节替换\" tabindex=\"-1\"> 类加载与动态字节替换</h1>\n",
      "date_published": "2022-10-04T08:46:29.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "APT实现原理",
      "url": "https://yangzhanlong.github.io/java/base/APT%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html",
      "id": "https://yangzhanlong.github.io/java/base/APT%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html",
      "content_html": "<h1 id=\"apt实现原理\" tabindex=\"-1\"> APT实现原理</h1>\n<h2 id=\"spi机制实现原理\" tabindex=\"-1\"> SPI机制实现原理</h2>\n<h2 id=\"apt注解处理器工作原理\" tabindex=\"-1\"> APT注解处理器工作原理</h2>\n<h2 id=\"javac源码分析\" tabindex=\"-1\"> javac源码分析</h2>\n",
      "date_published": "2022-10-04T08:46:29.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "动态代理",
      "url": "https://yangzhanlong.github.io/java/base/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html",
      "id": "https://yangzhanlong.github.io/java/base/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html",
      "content_html": "<h1 id=\"动态代理\" tabindex=\"-1\"> 动态代理</h1>\n",
      "date_published": "2022-10-04T08:46:29.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "反射",
      "url": "https://yangzhanlong.github.io/java/base/%E5%8F%8D%E5%B0%84.html",
      "id": "https://yangzhanlong.github.io/java/base/%E5%8F%8D%E5%B0%84.html",
      "content_html": "<h1 id=\"反射\" tabindex=\"-1\"> 反射</h1>\n",
      "date_published": "2022-10-04T08:46:29.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "泛型",
      "url": "https://yangzhanlong.github.io/java/base/%E6%B3%9B%E5%9E%8B.html",
      "id": "https://yangzhanlong.github.io/java/base/%E6%B3%9B%E5%9E%8B.html",
      "content_html": "<h1 id=\"泛型\" tabindex=\"-1\"> 泛型</h1>\n",
      "date_published": "2022-10-04T08:46:29.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "注解的使用",
      "url": "https://yangzhanlong.github.io/java/base/%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8.html",
      "id": "https://yangzhanlong.github.io/java/base/%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8.html",
      "content_html": "<h1 id=\"注解的使用\" tabindex=\"-1\"> 注解的使用</h1>\n<iframe\n:src=\"$withBase('/markmap/注解的使用.html')\"\nwidth=\"60%\"\nheight=\"200\"\nframeborder=\"0\"\nscrolling=\"No\"\nleftmargin=\"0\"\ntopmargin=\"0\"\n/>\n<h2 id=\"注解-apt-注解处理器-butterknife实现原理\" tabindex=\"-1\"> 注解+APT(注解处理器) (ButterKnife实现原理)</h2>\n<h3 id=\"apt实现原理\" tabindex=\"-1\"> APT实现原理</h3>\n<blockquote>\n<p>在java编译阶段(java-&gt;class)，通过注解处理器(APT)解析注解，生成新的代码，把新的代码编译成字节码。</p>\n</blockquote>\n<h3 id=\"apt使用\" tabindex=\"-1\"> APT使用</h3>\n<ol>\n<li>引入<code>annotationProcessor</code>，在编译的时候使用注解处理器，需要用<code>@AutoService</code>注解标识</li>\n</ol>\n<div><pre><code><span>dependencies</span> <span>{</span>\n    <span>//......</span>\n    <span>implementation</span> <span>project</span><span>(</span>path<span>:</span> <span>':annotations'</span><span>)</span>\n    annotationProcessor  <span>project</span><span>(</span>path<span>:</span> <span>':annotation_compiler'</span><span>)</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><ol start=\"2\">\n<li>定义注解<code>BindView</code>，用于使用注解的地方</li>\n</ol>\n<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span><span>FIELD</span><span>)</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span><span>SOURCE</span><span>)</span>\n<span>public</span> <span>@interface</span> <span>BindView</span> <span>{</span>\n    <span>int</span> <span>value</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><ol start=\"3\">\n<li>定义接口，用于绑定Activity</li>\n</ol>\n<div><pre><code><span>public</span> <span>interface</span> <span>IBind</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n    <span>void</span> <span>bind</span><span>(</span><span>T</span> target<span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><ol start=\"4\">\n<li>创建绑定Activity工具类，运行的时候动态创建对应的类并执行相应的代码</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>MyButterKnife</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>bind</span><span>(</span><span>Activity</span> activity<span>)</span><span>{</span>\n        <span>String</span> name<span>=</span>activity<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>\"_ViewBinding\"</span><span>;</span>\n        <span>try</span><span>{</span>\n            <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> aClass<span>=</span><span>Class</span><span>.</span><span>forName</span><span>(</span>name<span>)</span><span>;</span>\n            <span>IBind</span> iBinder<span>=</span><span>(</span><span>IBind</span><span>)</span>aClass<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>\n            iBinder<span>.</span><span>bind</span><span>(</span>activity<span>)</span><span>;</span>\n        <span>}</span><span>catch</span><span>(</span><span>Exception</span> e<span>)</span><span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start=\"5\">\n<li>创建注解处理器，继承<code>AbstractProcessor</code>，并在<code>process</code>的回调使用<code>Filer</code>把代码的写入到指定的文件。</li>\n</ol>\n<div><pre><code><span>@AutoService</span><span>(</span><span>Processor</span><span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>class</span> <span>AnnotationsCompiler</span> <span>extends</span> <span>AbstractProcessor</span> <span>{</span>\n    <span>//1.支持的版本</span>\n    <span>@Override</span>\n    <span>public</span> <span>SourceVersion</span> <span>getSupportedSourceVersion</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>SourceVersion</span><span>.</span><span>latestSupported</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>//2.能用来处理哪些注解</span>\n    <span>@Override</span>\n    <span>public</span> <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>getSupportedAnnotationTypes</span><span>(</span><span>)</span> <span>{</span>\n        <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> types <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        types<span>.</span><span>add</span><span>(</span><span>BindView</span><span>.</span><span>class</span><span>.</span><span>getCanonicalName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>return</span> types<span>;</span>\n    <span>}</span>\n\n    <span>//3.定义一个用来生成APT目录下面的文件的对象</span>\n    <span>Filer</span> filer<span>;</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>synchronized</span> <span>void</span> <span>init</span><span>(</span><span>ProcessingEnvironment</span> processingEnvironment<span>)</span> <span>{</span>\n        <span>super</span><span>.</span><span>init</span><span>(</span>processingEnvironment<span>)</span><span>;</span>\n        filer <span>=</span> processingEnvironment<span>.</span><span>getFiler</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 所有的坏事都在这个方法中实现\n     * <span>@param</span> <span>set</span>\n     * <span>@param</span> <span>roundEnvironment</span>\n     * <span>@return</span>\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>boolean</span> <span>process</span><span>(</span><span>Set</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>TypeElement</span><span>></span></span> set<span>,</span> <span>RoundEnvironment</span> roundEnvironment<span>)</span> <span>{</span>\n\n        <span>// 注意此方法会被回调3次，需要判断set不为空再执行</span>\n        <span>if</span> <span>(</span>set <span>==</span> <span>null</span> <span>||</span> set<span>.</span><span>size</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        processingEnv<span>.</span><span>getMessager</span><span>(</span><span>)</span><span>.</span><span>printMessage</span><span>(</span><span>Diagnostic<span>.</span>Kind</span><span>.</span><span>NOTE</span><span>,</span><span>\"jett---------------\"</span><span>+</span>set<span>)</span><span>;</span>\n        <span>//获取APP中所有用到了BindView注解的对象</span>\n        <span>Set</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Element</span><span>></span></span> elementsAnnotatedWith <span>=</span> roundEnvironment<span>.</span><span>getElementsAnnotatedWith</span><span>(</span><span>BindView</span><span>.</span><span>class</span><span>)</span><span>;</span>\n\n        <span>//TypeElement//类</span>\n        <span>//ExecutableElement//方法</span>\n        <span>//VariableElement//属性</span>\n        <span>//开始对elementsAnnotatedWith进行分类</span>\n        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>List</span><span>&lt;</span><span>VariableElement</span><span>></span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>Element</span> element <span>:</span> elementsAnnotatedWith<span>)</span> <span>{</span>\n            <span>VariableElement</span> variableElement <span>=</span> <span>(</span><span>VariableElement</span><span>)</span> element<span>;</span>\n            <span>String</span> activityName <span>=</span> variableElement<span>.</span><span>getEnclosingElement</span><span>(</span><span>)</span><span>.</span><span>getSimpleName</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n            <span>Class</span> aClass <span>=</span> variableElement<span>.</span><span>getEnclosingElement</span><span>(</span><span>)</span><span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>\n            <span>List</span><span><span>&lt;</span><span>VariableElement</span><span>></span></span> variableElements <span>=</span> map<span>.</span><span>get</span><span>(</span>activityName<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>variableElements <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                variableElements <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n                map<span>.</span><span>put</span><span>(</span>activityName<span>,</span> variableElements<span>)</span><span>;</span>\n            <span>}</span>\n            variableElements<span>.</span><span>add</span><span>(</span>variableElement<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>//需要生成文件内容</span>\n        <span>/*\n         * package com.example.butterknife_framework_demo;\n         *\n         * import com.example.butterknife_framework_demo.IBind;\n         *\n         * public class MainActivity_ViewBinding implements IBind&lt;com.example.butterknife_framework_demo.MainActivity> {\n         *     @Override\n         *     public void bind(com.example.butterknife_framework_demo.MainActivity target) {\n         *         target.textView = (android.widget.TextView) target.findViewById(2131165359);\n         *\n         *     }\n         * }\n         */</span>\n        <span>if</span> <span>(</span>map<span>.</span><span>size</span><span>(</span><span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>Writer</span> writer <span>=</span> <span>null</span><span>;</span>\n            <span>Iterator</span><span><span>&lt;</span><span>String</span><span>></span></span> iterator <span>=</span> map<span>.</span><span>keySet</span><span>(</span><span>)</span><span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>\n            <span>while</span> <span>(</span>iterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>String</span> activityName <span>=</span> iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>\n                <span>List</span><span><span>&lt;</span><span>VariableElement</span><span>></span></span> variableElements <span>=</span> map<span>.</span><span>get</span><span>(</span>activityName<span>)</span><span>;</span>\n                <span>//得到包名</span>\n                <span>TypeElement</span> enclosingElement <span>=</span> <span>(</span><span>TypeElement</span><span>)</span> variableElements<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>.</span><span>getEnclosingElement</span><span>(</span><span>)</span><span>;</span>\n                <span>String</span> packageName <span>=</span> processingEnv<span>.</span><span>getElementUtils</span><span>(</span><span>)</span><span>.</span><span>getPackageOf</span><span>(</span>enclosingElement<span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n                <span>try</span> <span>{</span>\n                    <span>JavaFileObject</span> sourceFile <span>=</span> filer<span>.</span><span>createSourceFile</span><span>(</span>packageName <span>+</span> <span>\".\"</span> <span>+</span> activityName <span>+</span> <span>\"_ViewBinding\"</span><span>)</span><span>;</span>\n                    writer <span>=</span> sourceFile<span>.</span><span>openWriter</span><span>(</span><span>)</span><span>;</span>\n                    <span>//        package com.example.dn_butterknife;</span>\n                    writer<span>.</span><span>write</span><span>(</span><span>\"package \"</span> <span>+</span> packageName <span>+</span> <span>\";\\n\"</span><span>)</span><span>;</span>\n                    <span>//        import com.example.dn_butterknife.IBind;</span>\n                    writer<span>.</span><span>write</span><span>(</span><span>\"import \"</span> <span>+</span> packageName <span>+</span> <span>\".IBind;\\n\"</span><span>)</span><span>;</span>\n                    <span>//        public class MainActivity_ViewBinding implements IBind&lt;</span>\n                    <span>//        com.example.dn_butterknife.MainActivity>{</span>\n                    writer<span>.</span><span>write</span><span>(</span><span>\"public class \"</span> <span>+</span> activityName <span>+</span> <span>\"_ViewBinding implements IBind&lt;\"</span> <span>+</span>\n                            packageName <span>+</span> <span>\".\"</span> <span>+</span> activityName <span>+</span> <span>\">{\\n\"</span><span>)</span><span>;</span>\n                    <span>//            public void bind(com.example.dn_butterknife.MainActivity target) {</span>\n                    writer<span>.</span><span>write</span><span>(</span><span>\" @Override\\n\"</span> <span>+</span>\n                            <span>\" public void bind(\"</span> <span>+</span> packageName <span>+</span> <span>\".\"</span> <span>+</span> activityName <span>+</span> <span>\" target){\"</span><span>)</span><span>;</span>\n                    <span>//target.tvText=(android.widget.TextView)target.findViewById(2131165325);</span>\n                    <span>for</span> <span>(</span><span>VariableElement</span> variableElement <span>:</span> variableElements<span>)</span> <span>{</span>\n                        <span>//得到名字</span>\n                        <span>String</span> variableName <span>=</span> variableElement<span>.</span><span>getSimpleName</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n                        <span>//得到ID</span>\n                        <span>int</span> id <span>=</span> variableElement<span>.</span><span>getAnnotation</span><span>(</span><span>BindView</span><span>.</span><span>class</span><span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>;</span>\n                        <span>//得到类型</span>\n                        <span>TypeMirror</span> typeMirror <span>=</span> variableElement<span>.</span><span>asType</span><span>(</span><span>)</span><span>;</span>\n                        writer<span>.</span><span>write</span><span>(</span><span>\"target.\"</span> <span>+</span> variableName <span>+</span> <span>\"=(\"</span> <span>+</span> typeMirror <span>+</span> <span>\")target.findViewById(\"</span> <span>+</span> id <span>+</span> <span>\");\\n\"</span><span>)</span><span>;</span>\n                    <span>}</span>\n\n                    writer<span>.</span><span>write</span><span>(</span><span>\"\\n}}\"</span><span>)</span><span>;</span>\n\n                <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span> <span>finally</span> <span>{</span>\n                    <span>if</span> <span>(</span>writer <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                        <span>try</span> <span>{</span>\n                            writer<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n                        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n                            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                        <span>}</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"注解-反射-动态代理\" tabindex=\"-1\"> 注解+反射+动态代理</h2>\n<blockquote>\n<p>实现运行时通过反射解析注解，通过动态代理代理注解的接口，回调到注解的地方。</p>\n</blockquote>\n<p>以点击事件做为一个例子：</p>\n<ol>\n<li>定义运行时注解</li>\n</ol>\n<div><pre><code><span>/**\n * 提供其他注解使用，例如:OnClick注解, OnLongClick注解\n */</span>\n<span>@Target</span><span>(</span><span>ElementType</span><span>.</span><span>ANNOTATION_TYPE</span><span>)</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span><span>RUNTIME</span><span>)</span>\n<span>public</span> <span>@interface</span> <span>Event</span> <span>{</span>\n    <span>//需要代理的方法->setOnClickListener</span>\n    <span>String</span> <span>function</span><span>(</span><span>)</span><span>;</span>\n    <span>//需要代理的接口类->View.OnClickListener()</span>\n    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>interfaceClass</span><span>(</span><span>)</span><span>;</span>\n    <span>//需要代理的具体接口->onClick</span>\n    <span>String</span> <span>callbackMethod</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start=\"2\">\n<li>定义OnClick注解和OnLongClick注解</li>\n</ol>\n<div><pre><code><span>// OnClick</span>\n<span>@Target</span><span>(</span><span>ElementType</span><span>.</span><span>METHOD</span><span>)</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span><span>RUNTIME</span><span>)</span>\n<span>@Event</span><span>(</span>function <span>=</span> <span>\"setOnClickListener\"</span>\n        <span>,</span> interfaceClass <span>=</span> <span>View<span>.</span>OnClickListener</span><span>.</span><span>class</span>\n        <span>,</span>callbackMethod <span>=</span> <span>\"onClick\"</span><span>)</span>\n<span>public</span> <span>@interface</span> <span>OnClick</span> <span>{</span>\n    <span>int</span><span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>-</span><span>1</span><span>;</span>\n<span>}</span>\n\n<span>// OnLongClick</span>\n<span>@Event</span><span>(</span>function <span>=</span> <span>\"setOnLongClickListener\"</span>\n        <span>,</span> interfaceClass <span>=</span> <span>View<span>.</span>OnLongClickListener</span><span>.</span><span>class</span>\n        <span>,</span>callbackMethod <span>=</span> <span>\"onLongClick\"</span><span>)</span>\n<span>@Target</span><span>(</span><span>ElementType</span><span>.</span><span>METHOD</span><span>)</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span><span>RUNTIME</span><span>)</span>\n<span>public</span> <span>@interface</span> <span>OnLongClick</span> <span>{</span>\n    <span>int</span><span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>-</span><span>1</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start=\"3\">\n<li>使用注解</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>MainActivity</span> <span>extends</span> <span>AppCompatActivity</span> <span>{</span>\n    <span>@Override</span>\n    <span>protected</span> <span>void</span> <span>onCreate</span><span>(</span><span>Bundle</span> savedInstanceState<span>)</span> <span>{</span>\n        <span>super</span><span>.</span><span>onCreate</span><span>(</span>savedInstanceState<span>)</span><span>;</span>\n        <span>setContentView</span><span>(</span><span>R</span><span>.</span>layout<span>.</span>activity_main<span>)</span><span>;</span>\n        <span>InjectUtils</span><span>.</span><span>inject</span><span>(</span><span>this</span><span>)</span><span>;</span>\n    <span>}</span>\n    \n    <span>@OnClick</span><span>(</span><span>{</span><span>R</span><span>.</span>id<span>.</span>btn1<span>,</span><span>R</span><span>.</span>id<span>.</span>btn2<span>}</span><span>)</span>\n    <span>public</span> <span>void</span> <span>click</span><span>(</span><span>View</span> view<span>)</span><span>{</span>\n        <span>Toast</span><span>.</span><span>makeText</span><span>(</span><span>this</span><span>,</span> <span>\"按下1\"</span><span>,</span> <span>Toast</span><span>.</span><span>LENGTH_SHORT</span><span>)</span><span>.</span><span>show</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@OnLongClick</span><span>(</span><span>{</span><span>R</span><span>.</span>id<span>.</span>btn2<span>}</span><span>)</span>\n    <span>public</span> <span>boolean</span> <span>longClick</span><span>(</span><span>View</span> view<span>)</span><span>{</span>\n        <span>Toast</span><span>.</span><span>makeText</span><span>(</span><span>this</span><span>,</span> <span>\"按下2\"</span><span>,</span> <span>Toast</span><span>.</span><span>LENGTH_SHORT</span><span>)</span><span>.</span><span>show</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start=\"4\">\n<li>实现<code>InvocationHandler</code>，代理需要回调的接口</li>\n</ol>\n<div><pre><code><span>/**\n * 这个类用来代理new View.OnClickListener()对象\n * 并执行这个对象身上的onClick方法\n */</span>\n<span>public</span> <span>class</span> <span>ListenerInvocationHandler</span> <span>implements</span> <span>InvocationHandler</span> <span>{</span>\n\n    <span>private</span> <span>Object</span> activity<span>;</span>\n    <span>private</span> <span>Method</span> activityMethod<span>;</span>\n\n    <span>public</span> <span>ListenerInvocationHandler</span><span>(</span><span>Object</span> activity<span>,</span> <span>Method</span> activityMethod<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>activity <span>=</span> activity<span>;</span>\n        <span>this</span><span>.</span>activityMethod <span>=</span> activityMethod<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 就表示onClick的执行\n     * 程序执行onClick方法，就会转到这里来\n     * 因为框架中不直接执行onClick\n     * 所以在框架中必然有个地方让invoke和onClick关联上\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n        <span>//在这里去调用被注解了的click();</span>\n        <span>return</span> activityMethod<span>.</span><span>invoke</span><span>(</span>activity<span>,</span>args<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start=\"5\">\n<li>处理解析注解，动态代理接口，执行回调事件</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>InjectUtils</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>inject</span><span>(</span><span>Object</span> context<span>)</span> <span>{</span>\n        <span>injectClick</span><span>(</span>context<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>static</span> <span>void</span> <span>injectClick</span><span>(</span><span>Object</span> context<span>)</span> <span>{</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz <span>=</span> context<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>\n        <span>Method</span><span>[</span><span>]</span> methods <span>=</span> clazz<span>.</span><span>getDeclaredMethods</span><span>(</span><span>)</span><span>;</span>\n\n        <span>for</span> <span>(</span><span>Method</span> method <span>:</span> methods<span>)</span> <span>{</span>\n            <span>Annotation</span><span>[</span><span>]</span> annotations <span>=</span> method<span>.</span><span>getAnnotations</span><span>(</span><span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>Annotation</span> annotation <span>:</span> annotations<span>)</span> <span>{</span>\n                <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> annotationClass <span>=</span> annotation<span>.</span><span>annotationType</span><span>(</span><span>)</span><span>;</span>\n                <span>Event</span> eventBase <span>=</span> annotationClass<span>.</span><span>getAnnotation</span><span>(</span><span>Event</span><span>.</span><span>class</span><span>)</span><span>;</span>\n                <span>//判断是不是事件处理程序  onClick  onLongClink</span>\n                <span>if</span> <span>(</span>eventBase <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                    <span>continue</span><span>;</span>\n                <span>}</span>\n                \n                <span>// 获取注解的Event注解的参数</span>\n                <span>String</span> function <span>=</span> eventBase<span>.</span><span>function</span><span>(</span><span>)</span><span>;</span>\n                <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> interfaceClass <span>=</span> eventBase<span>.</span><span>interfaceClass</span><span>(</span><span>)</span><span>;</span>\n                <span>String</span> callBackMethod <span>=</span> eventBase<span>.</span><span>callbackMethod</span><span>(</span><span>)</span><span>;</span>\n\n                <span>Method</span> valueMethod<span>;</span>\n                <span>try</span> <span>{</span>\n                    valueMethod <span>=</span> annotationClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"value\"</span><span>)</span><span>;</span>\n                    <span>int</span><span>[</span><span>]</span> viewId <span>=</span> <span>(</span><span>int</span><span>[</span><span>]</span><span>)</span> valueMethod<span>.</span><span>invoke</span><span>(</span>annotation<span>)</span><span>;</span>\n                    <span>if</span> <span>(</span>viewId <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                        <span>return</span><span>;</span>\n                    <span>}</span>\n                    <span>for</span> <span>(</span><span>int</span> id <span>:</span> viewId<span>)</span> <span>{</span>\n                        <span>//执行 findViewById 获取view对象</span>\n                        <span>Method</span> findViewById <span>=</span> clazz<span>.</span><span>getMethod</span><span>(</span><span>\"findViewById\"</span><span>,</span> <span>int</span><span>.</span><span>class</span><span>)</span><span>;</span>\n                        <span>View</span> view <span>=</span> <span>(</span><span>View</span><span>)</span> findViewById<span>.</span><span>invoke</span><span>(</span>context<span>,</span> id<span>)</span><span>;</span>\n                        <span>if</span> <span>(</span>view <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                            <span>continue</span><span>;</span>\n                        <span>}</span>\n                        <span>// context->activity   method->click</span>\n                        <span>ListenerInvocationHandler</span> listenerInvocationHandler <span>=</span> <span>new</span> <span>ListenerInvocationHandler</span><span>(</span>context<span>,</span> method<span>)</span><span>;</span>\n                        <span>// new View.OnClickListener()</span>\n                        <span>Object</span> proxy <span>=</span> <span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span>interfaceClass<span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>,</span> <span>new</span> <span>Class</span><span>[</span><span>]</span><span>{</span>interfaceClass<span>}</span><span>,</span> listenerInvocationHandler<span>)</span><span>;</span>\n\n                        <span>// 执行 view.setOnClickListener（new View.OnClickListener()）</span>\n                        <span>Method</span> onClickMethod <span>=</span> view<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getMethod</span><span>(</span>function<span>,</span> interfaceClass<span>)</span><span>;</span>\n                        <span>// 当点击按钮的时候，就会执行ListenerInvocationHandler的invoke方法，从而回调注解的地方</span>\n                        onClickMethod<span>.</span><span>invoke</span><span>(</span>view<span>,</span> proxy<span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"总结\" tabindex=\"-1\"> 总结</h2>\n<ol>\n<li>注解+APT的使用流程\n<ul>\n<li>引入<code>annotationProcessor</code></li>\n<li>定义注解</li>\n<li>创建注解处理器</li>\n<li>写入自定义的代码到自定义的文件</li>\n<li>使用注解</li>\n</ul>\n</li>\n<li>ButterKnife的实现原理</li>\n</ol>\n<div><pre><code>在编译时找到项目中所有注解的元素→根据类名进行分类→\n  \n遍历对每个类创建对应的文件→在文件中根据注解使用Writer 我们的代码→\n\n最后写入文件→在运行的时候，通过bind()接口传入activity→反射获取当前类对应的文件→\n\n获取对应的构造器创建对象→执行响应的代码逻辑\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start=\"3\">\n<li>使用APT的框架\n<ul>\n<li>ButterKnife</li>\n<li>databinding</li>\n<li>dagger2</li>\n<li>hilt</li>\n<li>arouter</li>\n</ul>\n</li>\n<li>注解+反射+动态代理</li>\n</ol>\n",
      "date_published": "2022-10-04T08:46:29.000Z",
      "date_modified": "2022-10-07T03:29:13.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "编译时处理",
      "url": "https://yangzhanlong.github.io/java/base/%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%84%E7%90%86.html",
      "id": "https://yangzhanlong.github.io/java/base/%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%84%E7%90%86.html",
      "content_html": "<h1 id=\"编译时处理\" tabindex=\"-1\"> 编译时处理</h1>\n",
      "date_published": "2022-10-04T08:46:29.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "自定义注解",
      "url": "https://yangzhanlong.github.io/java/base/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3.html",
      "id": "https://yangzhanlong.github.io/java/base/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3.html",
      "content_html": "<h1 id=\"自定义注解\" tabindex=\"-1\"> 自定义注解</h1>\n<h2 id=\"注解的基本元素\" tabindex=\"-1\"> 注解的基本元素</h2>\n<p>一个简单的注解的例子:</p>\n<div><pre><code><span>public</span> <span>@interface</span> <span>BindView</span> <span>{</span>\n    <span>int</span> <span>value</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><ul>\n<li>\n<p>修饰符 访问修饰符必须为public,不写默认为pubic</p>\n</li>\n<li>\n<p>关键字  <code>@interface</code></p>\n</li>\n<li>\n<p>注解名称 自定义注解的名称 <code>BindView</code></p>\n</li>\n<li>\n<p>注解类型元素 注解的内容 <code>int value()</code></p>\n</li>\n</ul>\n<h2 id=\"使用元注解修饰注解\" tabindex=\"-1\"> 使用元注解修饰注解</h2>\n<ul>\n<li>@Target  表示该注解应用到的目标类型</li>\n<li>@Retention  表示该注解应用到的生命周期</li>\n<li>@Document  表示该注解被Javadoc 或类似的工具文档化</li>\n<li>@Inherited  表示所标记的类的子类也会拥有这个注解</li>\n</ul>\n<h4 id=\"target\" tabindex=\"-1\"> @Target</h4>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ElementType.TYPE</td>\n<td>应用于类、接口（包括注解类型）、枚举</td>\n</tr>\n<tr>\n<td>ElementType.FIELD</td>\n<td>应用于属性（包括枚举中的常量）</td>\n</tr>\n<tr>\n<td>ElementType.METHOD</td>\n<td>应用于方法</td>\n</tr>\n<tr>\n<td>ElementType.PARAMETER</td>\n<td>应用于方法的形参</td>\n</tr>\n<tr>\n<td>ElementType.CONSTRUCTOR</td>\n<td>应用于构造函数</td>\n</tr>\n<tr>\n<td>ElementType.LOCAL_VARIABLE</td>\n<td>应用于局部变量</td>\n</tr>\n<tr>\n<td>ElementType.ANNOTATION_TYPE</td>\n<td>应用于注解类型</td>\n</tr>\n<tr>\n<td>ElementType.PACKAGE</td>\n<td>应用于包</td>\n</tr>\n<tr>\n<td>ElementType.TYPE_PARAMETER</td>\n<td>1.8版本新增，应用于类型变量</td>\n</tr>\n<tr>\n<td>ElementType.TYPE_USE</td>\n<td>1.8版本新增，应用于任何使用类型的语句中（例如声明语句、泛型和强制转换语句中的类型）</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"retention\" tabindex=\"-1\"> @Retention</h4>\n<p>RetentionPolicy.SOURCE         Java源文件阶段</p>\n<p>RetentionPolicy.CLASS          编译到class文件阶段</p>\n<p>RetentionPolicy.RUNTIME        运行期阶段</p>\n<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span><span>FIELD</span><span>)</span> <span>// 应用于属性</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span><span>SOURCE</span><span>)</span> <span>// Java源文件阶段</span>\n<span>public</span> <span>@interface</span> <span>BindView</span> <span>{</span>\n    <span>int</span> <span>value</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div>",
      "date_published": "2022-10-04T08:46:29.000Z",
      "date_modified": "2022-10-07T03:29:13.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "NIO与内部机制",
      "url": "https://yangzhanlong.github.io/java/io/nio.html",
      "id": "https://yangzhanlong.github.io/java/io/nio.html",
      "content_html": "<h1 id=\"nio与内部机制\" tabindex=\"-1\"> NIO与内部机制</h1>\n",
      "date_published": "2022-10-04T08:46:29.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "OKIO",
      "url": "https://yangzhanlong.github.io/java/io/okio.html",
      "id": "https://yangzhanlong.github.io/java/io/okio.html",
      "content_html": "<h1 id=\"okio\" tabindex=\"-1\"> OKIO</h1>\n",
      "date_published": "2022-10-04T08:46:29.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "从IO原理看序列化问题",
      "url": "https://yangzhanlong.github.io/java/io/%E5%BA%8F%E5%88%97%E5%8C%96.html",
      "id": "https://yangzhanlong.github.io/java/io/%E5%BA%8F%E5%88%97%E5%8C%96.html",
      "content_html": "<h1 id=\"从io原理看序列化问题\" tabindex=\"-1\"> 从IO原理看序列化问题</h1>\n",
      "date_published": "2022-10-04T08:46:29.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "AQS详解",
      "url": "https://yangzhanlong.github.io/java/concurrent/aqs.html",
      "id": "https://yangzhanlong.github.io/java/concurrent/aqs.html",
      "content_html": "<h1 id=\"aqs详解\" tabindex=\"-1\"> AQS详解</h1>\n",
      "date_published": "2022-10-04T08:46:29.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "CAS详解",
      "url": "https://yangzhanlong.github.io/java/concurrent/cas.html",
      "id": "https://yangzhanlong.github.io/java/concurrent/cas.html",
      "content_html": "<h1 id=\"cas详解\" tabindex=\"-1\"> CAS详解</h1>\n",
      "date_published": "2022-10-04T08:46:29.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java内存模型",
      "url": "https://yangzhanlong.github.io/java/concurrent/jmm.html",
      "id": "https://yangzhanlong.github.io/java/concurrent/jmm.html",
      "content_html": "<h1 id=\"java内存模型\" tabindex=\"-1\"> Java内存模型</h1>\n",
      "date_published": "2022-10-04T08:46:29.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Synchronize机制",
      "url": "https://yangzhanlong.github.io/java/concurrent/synchronize.html",
      "id": "https://yangzhanlong.github.io/java/concurrent/synchronize.html",
      "content_html": "<h1 id=\"synchronize机制\" tabindex=\"-1\"> Synchronize机制</h1>\n",
      "date_published": "2022-10-04T08:46:29.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "线程池",
      "url": "https://yangzhanlong.github.io/java/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html",
      "id": "https://yangzhanlong.github.io/java/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html",
      "content_html": "<h1 id=\"线程池\" tabindex=\"-1\"> 线程池</h1>\n",
      "date_published": "2022-10-04T08:46:29.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "音视频理论知识",
      "url": "https://yangzhanlong.github.io/video/media-base.html",
      "id": "https://yangzhanlong.github.io/video/media-base.html",
      "content_html": "<h1 id=\"音视频理论知识\" tabindex=\"-1\"> 音视频理论知识</h1>\n<h3 id=\"封装格式\" tabindex=\"-1\"> 封装格式</h3>\n<h4 id=\"什么是封装格式\" tabindex=\"-1\"> 什么是封装格式</h4>\n<p>视频封装格式也叫做容器，它是将已经编码压缩好的视频流、音频流以及字幕按照一定的方式放到一个文件中，方便播放软件播放。一般来说，视频文件的后缀名就是它的封装格式。</p>\n<h3 id=\"解码-编码\" tabindex=\"-1\"> 解码/编码</h3>\n<p>视频经过H.264解码器视频解码成视频原始数据YUV，YUV经过转换成ARGB8888，最后通过屏幕渲染\n音频经过AAC进行音频解码，解码成音频原始数据PCM，最后通过喇叭进行播放声音，(音频重采样，双声道转单声道)</p>\n<h4 id=\"为什么要进行编码\" tabindex=\"-1\"> 为什么要进行编码？</h4>\n<p>视频是连续的图像序列，由连续的帧构成，一帧即为一副图像\n由于人眼的视觉暂留效应，当帧序列以一定的速率播放时，我们看到的就是动作连续的视频\n这么多的连续图像数据如果不经过编码数据量就很大。</p>\n<p>比如一个1920<em>1080分辨率，每秒30帧的视频，一秒钟需要1920</em>1080<em>30</em>32  大小大概为237Mb的数据</p>\n<h4 id=\"编码的目的\" tabindex=\"-1\"> 编码的目的</h4>\n<p>编码的目的，就是为了压缩数据，有利于存储和传输，编码的核心思想就是去除冗余信息\n冗余信息有以下几点：</p>\n<ol>\n<li>空间冗余-&gt;图像内部相邻像素之间存在较强的相关性(相邻像素重复)</li>\n<li>时间冗余-&gt;视频图像序列中的不同帧之间的相关性(帧之间差值)</li>\n<li>视觉冗余-&gt;人眼不敏感的图像信息</li>\n</ol>\n<h4 id=\"视频解码流程图\" tabindex=\"-1\"> 视频解码流程图</h4>\n<img src=\"/assets/icon/image.png\" alt=\"\"/>\n<h4 id=\"音频编码流程图\" tabindex=\"-1\"> 音频编码流程图</h4>\n<img src=\"https://images4.imagebam.com/dd/bd/b0/MEDHCR4_o.png\" style=\"height: 500px; width: 600px\" alt=\"\"/>\n<h3 id=\"i帧-b帧-p帧\" tabindex=\"-1\"> I帧 B帧 P帧</h3>\n<ul>\n<li>\n<p>I帧:帧内编码帧,关键帧,I帧可以看作一个图像经过压缩之后的产物,可以单独解码出一个完整的图像(压缩率最低)</p>\n</li>\n<li>\n<p>P帧:向前预测/参考 编码帧,记录了本帧跟之前的一个关键帧(或P帧)的差别,解码时需用之前缓存的画面叠加上本帧定义的差别，生成最终的画面</p>\n</li>\n<li>\n<p>B帧:双向预测/参考 编码帧,记录了本帧与前后帧的差别,解码需要参考前面一个I帧或者P帧,同时也需要后面的P帧才能解码一张完整的图像</p>\n</li>\n</ul>\n<h3 id=\"h-264分成结构-vcl与nal\" tabindex=\"-1\"> H.264分成结构(VCL与NAL)</h3>\n<p>VCL(网络编码层):负责高效的视频内容表示 \t \t \t\t\t\t\t\t\t \t\t\t\t\t\nVCL就是被压缩编码后原始数据，在VCL数据封装到NAL单元中之后，才可以用于传输或存储。</p>\n<p>NAL(网络提取层):负责以网络所要求的恰当的方式对数据进行打包和 传送,是传输层。不管在本地播放还是网络播放,都要通过这一层来传输。</p>\n<h4 id=\"分层框架图\" tabindex=\"-1\"> 分层框架图</h4>\n<img src=\"https://images4.imagebam.com/59/67/f2/MEDHCY1_o.png\" alt=\"image.png\"/>\n<h3 id=\"nal-片-宏块\" tabindex=\"-1\"> NAL(片(宏块))</h3>\n<p>一帧图片经过 H.264 编码器之后，NAL单元就是装载着这些片(被编码为一个或多个片 slice), 每片包 含整数个宏块(至少一个宏块，最多包含整个图像宏块)。</p>\n<img src=\"https://images4.imagebam.com/e2/00/4e/MEDHDB4_o.png\" alt=\"image.png\"/>\n<p>一般H.264编码器的默认输出为：起始码+NAL单元</p>\n<p>起始码为：0x00000001或者\t0x000001</p>\n<h4 id=\"为什么需要起始码\" tabindex=\"-1\"> 为什么需要起始码</h4>\n<p>因为每个NALU都要分割，才能识别进行传输</p>\n<h4 id=\"为什么有两个起始码\" tabindex=\"-1\"> 为什么有两个起始码</h4>\n<p>0x000001代表一个nalu里面一个片可以搞定\n0x00000001代表一个nalu里面有很多个片</p>\n<h4 id=\"nal单元分析\" tabindex=\"-1\"> NAL单元分析</h4>\n<p>传输使用NAL单元\n一个NAL包括(起始码+类型+数据)\n起始码(两种)\n类型8位\n01100111\n第一位：1 不可以用  0 可用\n第2，3位：11代表这个帧很重要\n第4-8位：16进制 查表(7-&gt;sps)</p>\n<img src=\"https://images4.imagebam.com/e0/0c/3d/MEDHDG1_o.png\" alt=\"image.png\"/>\n<p>sps\n00 00 00 01 启始码   67 01100111  取低5位-&gt; 00000111-&gt; 7 -&gt; 序列参数集(记录多少个I帧，B帧，P帧)\npps\n00 00 00 01 启始码  68  01101000  取低5位-&gt; 00001000-&gt;8-&gt;图像序列集(图像宽高信息等)</p>\n<p>sel\n00 00 01 启始码   06  00000110  取低5位 -&gt;00000110-&gt;6 -&gt; 补充增强信息单元(SEL)(可以记录坐标信息，人员信息，后面解码的时候，可以通过代码获取此信息)</p>\n<img src=\"https://images4.imagebam.com/94/66/16/MEDHDM6_o.png\" alt=\"image\"/>\n<p>I帧\n00 00 01 65\n00 00 01  启始码\n65-&gt;01100101-&gt;低5位00000101-&gt; 5-&gt;(IDR图像中的片，I帧完整画面)</p>\n<img src=\"https://images4.imagebam.com/48/37/04/MEDHDR1_o.png\" alt=\"image.png\"/>\n<p>P帧\n00 00 01 41(不重要的P帧)\n41-&gt;01000001-&gt;取2,3位 10-&gt;代表不重要的帧-&gt;低5位-&gt;1(非IDR图像的片)\n00 00 01 61(重要的P帧)\n61-&gt;01100001-&gt;取2,3位  11-&gt;代表是重要的帧-&gt;低5位-&gt;1(非IDR图像的片)</p>\n<img src=\"https://images4.imagebam.com/9e/65/30/MEDHDVU_o.png\" alt=\"image.png\"/>\n<p>B帧\n00 00 01 01(B帧)\n01-&gt;00000001-&gt;取2,3位 00-&gt;代表不重要的帧-&gt;低5位-&gt;1(非IDR图像的片)</p>\n<img src=\"https://images4.imagebam.com/0c/f4/3e/MEDHE05_o.png\" alt=\"image.png\"/>\n<p>真实开放只分析：SPS,PPS,I帧,</p>\n<p>PTS&amp;DTS&amp;GOP序列\nDTS: 表示解码时间戳，在什么时候解码这一帧的数据\nPTD: 表示显示时间戳，在什么时候显示这一帧\n在没有B帧的情况，DTS和PTS的输出顺序是一样的\n因为B帧打乱了解码和显示的顺序(要解码B帧需要先解码后面的P帧)，所以一旦存在B帧，PTS和DTS就不同</p>\n<h3 id=\"gop序列\" tabindex=\"-1\"> GOP序列</h3>\n<p>SPS PPS I P B P B P B I 一组<br>\nSPS PPS I P B P B P B I 二组</p>\n",
      "date_published": "2022-09-19T05:41:16.000Z",
      "date_modified": "2022-09-19T05:41:16.000Z",
      "authors": [],
      "tags": [
        "音视频"
      ]
    },
    {
      "title": "Kotlin基础",
      "url": "https://yangzhanlong.github.io/android/kotlin/kotlin-base.html",
      "id": "https://yangzhanlong.github.io/android/kotlin/kotlin-base.html",
      "content_html": "<h1 id=\"kotlin基础\" tabindex=\"-1\"> Kotlin基础</h1>\n",
      "date_published": "2022-09-19T03:10:30.000Z",
      "date_modified": "2022-09-19T03:10:30.000Z",
      "authors": [],
      "tags": [
        "Kotlin"
      ]
    },
    {
      "title": "C++基础",
      "url": "https://yangzhanlong.github.io/android/ndk/C++-base.html",
      "id": "https://yangzhanlong.github.io/android/ndk/C++-base.html",
      "content_html": "<h3 id=\"c-基础\" tabindex=\"-1\"> C++基础</h3>\n<h3 id=\"c-函数适配器\" tabindex=\"-1\"> C++函数适配器</h3>\n<ul>\n<li>\n<p><code>find_if</code> 的<code>equal_to</code>无法直接查找指定字符串</p>\n</li>\n<li>\n<p>使用<code>bind2nd</code>函数适配器进行包裹<code>equal_to</code>，会把字符串放到<code>equal_to</code>里面进行比较</p>\n</li>\n</ul>\n<div><pre><code><span>// 1.C++的函数适配器。  第一版本</span>\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span><span>#</span><span>include</span> <span>&lt;set></span> <span>// stl包</span></span>\n<span><span>#</span><span>include</span> <span>&lt;algorithm></span> <span>// 算法包</span></span>\n<span>using</span> <span>namespace</span> std<span>;</span>\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n  <span>// std::cout &lt;&lt; \"算法包\" &lt;&lt; std::endl;</span>\n\n  set<span>&lt;</span>string<span>,</span> less<span>&lt;</span>string<span>>></span> setVar<span>;</span>\n  setVar<span>.</span><span>insert</span><span>(</span><span>\"AAAA\"</span><span>)</span><span>;</span>\n  setVar<span>.</span><span>insert</span><span>(</span><span>\"BBBB\"</span><span>)</span><span>;</span>\n  setVar<span>.</span><span>insert</span><span>(</span><span>\"CCCC\"</span><span>)</span><span>;</span>\n\n  <span>for</span> <span>(</span>set<span>&lt;</span>string<span>></span><span>::</span>iterator iteratorVar <span>=</span> setVar<span>.</span><span>begin</span><span>(</span><span>)</span><span>;</span> iteratorVar <span>!=</span> setVar<span>.</span><span>end</span><span>(</span><span>)</span> <span>;</span> iteratorVar<span>++</span><span>)</span> <span>{</span>\n      cout <span>&lt;&lt;</span> <span>*</span>iteratorVar <span>&lt;&lt;</span> endl<span>;</span>\n  <span>}</span>\n\n  <span>// find_if</span>\n  <span>// equal_to 比较用的</span>\n  set<span>&lt;</span>string<span>,</span> less<span>&lt;</span>string<span>>></span><span>::</span>iterator iteratorResult <span>=</span>\n\n          <span>// 解决尴尬的问题  equal_to 需要比较的 内容没有 使用 函数适配器 解决</span>\n          <span>// 现在的问题是： 没有办法把 CCCC 传递给 const _Tp&amp; __y，就没法去比较</span>\n          <span>// find_if(setVar.begin(), setVar.end(), equal_to&lt;string>(\"CCCC\"), \"CCCC\");</span>\n\n          <span>// 使用函数适配器后，就能够 CCCC 传递给了  const _Tp&amp; __y，</span>\n          <span>// setVar.begin(), setVar.end() 会把这些元素取出来 const _Tp&amp; __x</span>\n          <span>// x == y 的比较</span>\n          <span>find_if</span><span>(</span>setVar<span>.</span><span>begin</span><span>(</span><span>)</span><span>,</span> setVar<span>.</span><span>end</span><span>(</span><span>)</span><span>,</span> <span>bind2nd</span><span>(</span><span><span>equal_to</span><span><span>&lt;</span>string<span>></span></span></span><span>(</span><span>)</span><span>,</span> <span>\"CCCC\"</span><span>)</span><span>)</span><span>;</span>\n\n  <span>if</span> <span>(</span>iteratorResult <span>!=</span> setVar<span>.</span><span>end</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      cout <span>&lt;&lt;</span> <span>\"查找到了\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n  <span>}</span> <span>else</span> <span>{</span>\n      cout <span>&lt;&lt;</span> <span>\"没有查找到\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n  <span>}</span>\n\n  <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code>template <span>&lt;</span>class _InputIterator<span>,</span> class _Predicate<span>></span>\n<span>find_if</span><span>(</span>_InputIterator __first<span>,</span> _InputIterator __last<span>,</span> _Predicate __pred<span>)</span> <span>{</span>\n  <span>for</span> <span>(</span><span>;</span> __first <span>!=</span> __last<span>;</span> <span>++</span>__first<span>)</span>\n    <span>if</span> <span>(</span><span>__pred</span><span>(</span><span>*</span>__first<span>)</span><span>)</span>\n      <span>break</span><span>;</span>\n  <span>return</span> __first<span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code>template <span>&lt;</span>class __Operation<span>></span>\nclass binder2nd <span>:</span> public unary_function<span>&lt;</span>typename __Operation<span>::</span>first_argument_type<span>,</span>\n                            typename __Operation<span>::</span>result_type<span>></span>\n<span>{</span>\nprotected<span>:</span>\n    __Operation                                op<span>;</span>\n    typename __Operation<span>::</span>second_argument_type value<span>;</span>\npublic<span>:</span>\n    <span>binder2nd</span><span>(</span><span>const</span> __Operation<span>&amp;</span> __x<span>,</span> <span>const</span> typename __Operation<span>::</span>second_argument_type __y<span>)</span>\n        <span>:</span> <span>op</span><span>(</span>__x<span>)</span><span>,</span> <span>value</span><span>(</span>__y<span>)</span> <span>{</span><span>}</span>\n                                \n    <span>// 使用仿函数</span>\n    typename __Operation<span>::</span>result_type <span>operator</span><span>(</span><span>)</span><span>(</span>typename __Operation<span>::</span>first_argument_type<span>&amp;</span> __x<span>)</span> <span>const</span>\n            <span>{</span>\n        \t\t<span>return</span> <span>op</span><span>(</span>__x<span>,</span> value<span>)</span><span>;</span> <span>// 这里的op 就是 equal_to</span>\n            <span>}</span>\n<span>}</span><span>;</span>\n\n\ntemplate <span>&lt;</span>class __Operation<span>,</span> class _Tp<span>></span>\nbinder2nd<span>&lt;</span>__Operation<span>></span>\n<span>bind2nd</span><span>(</span><span>const</span> __Operation<span>&amp;</span> __op<span>,</span> <span>const</span> _Tp<span>&amp;</span> __x<span>)</span>\n    <span>{</span><span>return</span> binder2nd<span>&lt;</span>__Operation<span>></span><span>(</span>__op<span>,</span> __x<span>)</span><span>;</span><span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"引用进阶\" tabindex=\"-1\"> 引用进阶</h3>\n<ol>\n<li>\n<p>引用的本质就是指针</p>\n</li>\n<li>\n<p>左值-&gt;获取，右值-&gt;修改</p>\n</li>\n<li>\n<p>例子：</p>\n<ul>\n<li><code>string getInfo()</code>是值传递，使用右值无法修改</li>\n<li><code>string &amp; getInfo_front()</code>是引用传递，使用右值可以修改</li>\n</ul>\n</li>\n</ol>\n<div><pre><code><span>// 1.引用进阶。</span>\n\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span><span>#</span><span>include</span> <span>&lt;vector></span></span>\n<span>using</span> <span>namespace</span> std<span>;</span>\n\n\n<span>// ============================ [左值 右值 引用]</span>\n<span>class</span> <span>Student</span> <span>{</span>\n<span>private</span><span>:</span>\n    string  info <span>=</span> <span>\"AAA\"</span><span>;</span> <span>// 旧变量</span>\n\n    <span>// TODO 第一种情况【getInfo函数的info 与 main函数的result 是旧与新的两个变量而已，他们是值传递，所以右值修改时，影响不了里面的旧变量】</span>\n<span>public</span><span>:</span>\n    string <span>getInfo</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>-></span>info<span>;</span>\n    <span>}</span>\n\n    <span>// TODO 第二种情况【getInfo函数的info 与 main函数的result 是引用关系，一块内存空间 有多个别名而已，所以右值修改时，直接影响旧变量】</span>\n<span>public</span><span>:</span>\n    string <span>&amp;</span> <span>getInfo_front</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>-></span>info<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    <span>/*vector&lt;int> v;\n    int r = v.front(); // 左值 获取\n    v.front() = 88; // 右值 修改*/</span>\n\n    Student student<span>;</span>\n\n    <span>// TODO 第一种情况</span>\n    student<span>.</span><span>getInfo</span><span>(</span><span>)</span> <span>=</span> <span>\"九阳神功\"</span><span>;</span>\n    string result <span>=</span> student<span>.</span><span>getInfo</span><span>(</span><span>)</span><span>;</span>\n    cout <span>&lt;&lt;</span> <span>\"第一种情况:\"</span> <span>&lt;&lt;</span> result <span>&lt;&lt;</span> endl<span>;</span>\n\n    <span>// TODO 第二种情况</span>\n    student<span>.</span><span>getInfo_front</span><span>(</span><span>)</span> <span>=</span> <span>\"三分归元气\"</span><span>;</span> <span>// 右值 修改内容</span>\n    result <span>=</span> student<span>.</span><span>getInfo_front</span><span>(</span><span>)</span><span>;</span> <span>// 左值 获取内容</span>\n    cout <span>&lt;&lt;</span> <span>\"第二种情况:\"</span> <span>&lt;&lt;</span> result <span>&lt;&lt;</span> endl<span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"线程\" tabindex=\"-1\"> 线程</h3>\n<ol>\n<li>创建线程<code>pthread_create(&amp;pthreadID, 0, customPthreadTask, &amp;number);</code></li>\n<li>参数说明:</li>\n</ol>\n<div><pre><code><span>int</span> <span>pthread_create</span> <span>(</span><span>pthread_t</span> <span>*</span><span>,</span>  <span>// 参数一：线程ID</span>\n                  \t<span>const</span> <span>pthread_attr_t</span> <span>*</span><span>,</span> <span>// 参数二：线程属性</span>\n                  \t<span>void</span> <span>*</span><span>(</span><span>*</span><span>)</span><span>(</span><span>void</span> <span>*</span><span>)</span><span>,</span> <span>// 参数三：函数指针的规则</span>\n                  \t<span>void</span> <span>*</span><span>)</span><span>;</span> <span>// 参数四：给函数指针传递的内容，void * 可以传递任何内容</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><ol start=\"3\">\n<li>线程阻塞：<code>pthread_join(pthreadID, 0);</code></li>\n<li>分离线程：main函数不等待线程继续执行</li>\n<li>非分离线程：main函数等待异步线程执行完再继续执行，使用<code>pthread_join</code></li>\n<li>应用场景:\n<ul>\n<li>多线程，使用分离线程，线程间互不影响</li>\n<li>协作，使用非分离线程，需要阻塞</li>\n</ul>\n</li>\n<li>线程案例:</li>\n</ol>\n<blockquote>\n<p>创建一个线程，把参数4的值带到参数3的函数去执行， 因为函数指针接受的是<code>void *</code>，表示任何类型的地址，所以需要使用<code>static_cast</code>来转换类型，然后进行取值</p>\n</blockquote>\n<blockquote>\n<p><strong>注意：参数3的函数必须返回0，不然会报错</strong></p>\n</blockquote>\n<div><pre><code><span>// pthreads 我们必须掌握的内容</span>\n\n<span>// pthreads 最简单的案例</span>\n\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span><span>#</span><span>include</span> <span>&lt;pthread.h></span> <span>// Derry Cygwin 有 pthreads支持</span></span>\nusing namespace std<span>;</span>\n\n<span>// void *(*)(void *)</span>\n<span>void</span> <span>*</span> <span>customPthreadTask</span><span>(</span><span>void</span> <span>*</span> pVoid<span>)</span> <span>{</span> <span>// 异步线程  相当于Java的Thread.run函数一样</span>\n    <span>// C++转换static_cast  转换指针操作的</span>\n    <span>int</span> <span>*</span> number <span>=</span> static_cast<span>&lt;</span><span>int</span> <span>*</span><span>></span><span>(</span>pVoid<span>)</span><span>;</span> <span>// pVoid==number int的地址，所以我用int*接收，很合理</span>\n    cout <span>&lt;&lt;</span> <span>\"异步线程执行了:\"</span> <span>&lt;&lt;</span> <span>*</span>number <span>&lt;&lt;</span> endl<span>;</span>\n\n    <span>return</span> <span>0</span><span>;</span> <span>// 坑 坑 坑，必须返回，否则有错误，不好查询</span>\n<span>}</span>\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    <span>int</span> number <span>=</span> <span>9527</span><span>;</span>\n\n    <span>/**\n      int pthread_create (pthread_t *,  // 参数一：线程ID\n                        const pthread_attr_t *, // 参数二：线程属性\n\t\t                void *(*)(void *), // 参数三：函数指针的规则\n\t\t                void *); // 参数四：给函数指针传递的内容，void * 可以传递任何内容\n     */</span>\n    <span>pthread_t</span> pthreadID<span>;</span> <span>// 线程ID，每个线程都需要有的线程ID</span>\n\n    <span>pthread_create</span><span>(</span><span>&amp;</span>pthreadID<span>,</span> <span>0</span><span>,</span> customPthreadTask<span>,</span> <span>&amp;</span>number<span>)</span><span>;</span>\n\n    <span>// 阻塞线程，等线程执行完继续执行</span>\n    <span>pthread_join</span><span>(</span>pthreadID<span>,</span> <span>0</span><span>)</span><span>;</span>\n    cout <span>&lt;&lt;</span> <span>\"main函数即将弹栈...\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"互斥锁\" tabindex=\"-1\"> 互斥锁</h3>\n<ol>\n<li>\n<p>C++ 互斥锁(<code>pthread_mutex_t</code>) == Java版本（<code>synchronize</code>） 多线程操作的安全  持有内置锁</p>\n</li>\n<li>\n<p>使用步骤：</p>\n<ul>\n<li>\n<p>定义互斥锁-&gt; <code>pthread_mutex_t mutex;</code>  必须是全局的</p>\n</li>\n<li>\n<p>初始化互斥锁-&gt;<code>pthread_mutex_lock(&amp;mutex)</code></p>\n</li>\n<li>\n<p>获取锁-&gt;<code>pthread_mutex_lock(&amp;mutex);</code></p>\n</li>\n<li>\n<p>释放锁-&gt;<code>pthread_mutex_unlock(&amp;mutex);</code></p>\n</li>\n<li>\n<p>销毁锁-&gt;<code>pthread_mutex_destroy(&amp;mutex);</code></p>\n</li>\n</ul>\n</li>\n<li>\n<p>使用案例：</p>\n</li>\n</ol>\n<div><pre><code><span>// TODO  C++ 互斥锁 == Java版本（synchronize） 多线程操作的安全  持有内置锁</span>\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span><span>#</span><span>include</span> <span>&lt;pthread.h></span></span>\n<span><span>#</span><span>include</span> <span>&lt;queue></span></span>\n<span><span>#</span><span>include</span> <span>&lt;unistd.h></span> <span>// sleep（秒）</span></span>\n\nusing namespace std<span>;</span>\n\nqueue<span>&lt;</span><span>int</span><span>></span> queueData<span>;</span> <span>// 定义一个全局的队列，用于 存储/获取</span>\n\n<span>pthread_mutex_t</span> mutex<span>;</span> <span>// 定义一个互斥锁，注意：（Cygwin平台 此互斥锁，不能有野指针，坑）</span>\n\n<span>// void *(*)(void *)</span>\n<span>void</span> <span>*</span> <span>task</span><span>(</span><span>void</span> <span>*</span> pVoid<span>)</span> <span>{</span>\n\n    <span>/*synchronize(锁) {\n        // code\n    }*/</span>\n\n    <span>pthread_mutex_lock</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span> <span>// 锁住</span>\n\n    cout <span>&lt;&lt;</span> <span>\"异步线程-当前线程的标记是:\"</span> <span>&lt;&lt;</span> <span>*</span>static_cast<span>&lt;</span><span>int</span> <span>*</span><span>></span><span>(</span>pVoid<span>)</span> <span>&lt;&lt;</span> <span>\"异步线程\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n\n    <span>if</span> <span>(</span><span>!</span>queueData<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span> <span>{</span> <span>// 有元素</span>\n        <span>printf</span><span>(</span><span>\"异步线程-获取队列的数据:%d\\n\"</span><span>,</span> queueData<span>.</span><span>front</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        queueData<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span> <span>// 把数据弹出去，删除的意思</span>\n    <span>}</span> <span>else</span> <span>{</span> <span>// 没有元素</span>\n        <span>printf</span><span>(</span><span>\"异步线程-队列中没有数据了\\n\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// sleep(0.2);</span>\n\n    <span>pthread_mutex_unlock</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span> <span>// 解锁</span>\n\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n\n<span>int</span> <span>main</span><span>(</span><span>)</span>\n<span>{</span>\n    <span>// 初始化 互斥锁</span>\n    <span>pthread_mutex_init</span><span>(</span><span>&amp;</span>mutex<span>,</span> <span>NULL</span><span>)</span><span>;</span>\n\n    <span>// 给队列 初始化数据 手动增加数据进去</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>10001</span><span>;</span> i <span>&lt;</span> <span>10011</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>\n        queueData<span>.</span><span>push</span><span>(</span>i<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// 一次性定义10个线程</span>\n    <span>pthread_t</span> pthreadIDArray<span>[</span><span>10</span><span>]</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>\n        <span>pthread_create</span><span>(</span><span>&amp;</span>pthreadIDArray<span>[</span>i<span>]</span><span>,</span> <span>0</span><span>,</span> task<span>,</span> <span>&amp;</span>i<span>)</span><span>;</span>\n\n        <span>// 不能使用 join，如果使用（就变成顺序的方式，就没有多线程的意义了，所以不能写join）</span>\n        <span>// pthread_join(pthreadIDArray[i], 0);</span>\n    <span>}</span>\n\n    <span>// main函数等 异步线程</span>\n    <span>sleep</span><span>(</span><span>12</span><span>)</span><span>;</span>\n\n    <span>// 销毁 互斥锁</span>\n    <span>pthread_mutex_destroy</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span>\n    cout <span>&lt;&lt;</span> <span>\"main函数即将弹栈...\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n\n    <span>// 每次运行 效果都不同：1，8，9，10，3，2，5，8</span>\n    <span>// 每次运行 效果都是错乱</span>\n\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"条件变量\" tabindex=\"-1\"> 条件变量</h3>\n<ol>\n<li>\n<p>C++ 条件变量(<code>pthread_cond_t</code>)+互斥锁(<code>pthread_mutex_t</code>) == Java版本的（<code>notify</code> 与 <code>wait</code> 操作）</p>\n</li>\n<li>\n<p>条件变量，为了实现 等待 读取 等功能</p>\n</li>\n<li>\n<p>使用步骤：</p>\n<ol>\n<li>\n<p>初始化</p>\n<ul>\n<li>定义条件变量-&gt;<code>pthread_cond_t cond;</code></li>\n<li>定义互斥锁-&gt; <code>pthread_mutex_t mutex;</code></li>\n<li>初始化条件变量-&gt;<code>pthread_cond_init(&amp;cond, 0);</code></li>\n<li>初始化互斥锁-&gt;<code>pthread_mutex_init(&amp;mutex, 0);</code></li>\n</ul>\n</li>\n<li>\n<p>add加入队列中</p>\n<ul>\n<li>使用锁-&gt;<code>pthread_mutex_lock(&amp;mutex);</code></li>\n<li>通知条件变量-&gt;<code>pthread_cond_signal(&amp;cond)</code> 等同Java notify 单个的</li>\n<li>或者-&gt;<code>pthread_cond_broadcast(&amp;cond);</code>等同Java notifyAll 所有的</li>\n<li>释放锁-&gt;<code>pthread_mutex_unlock(&amp;mutex);</code></li>\n</ul>\n</li>\n<li>\n<p>get从队列中获取</p>\n<ul>\n<li>使用锁-&gt;<code>pthread_mutex_lock(&amp;mutex);</code></li>\n<li>等待-&gt;<code>pthread_cond_wait(&amp;cond, &amp;mutex);</code>等同相当于 Java的 wait 等待了[有可能被系统唤醒]</li>\n<li>释放锁-&gt;<code>pthread_mutex_unlock(&amp;mutex);</code></li>\n</ul>\n</li>\n<li>\n<p>回收锁和条件变量</p>\n<ul>\n<li>回收锁<code>pthread_mutex_destroy(&amp;mutex);</code></li>\n<li>回收条件变量<code>pthread_cond_destroy(&amp;cond);</code></li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>使用案例：</p>\n</li>\n</ol>\n<div><pre><code><span>// 生产者 消费者 工具类   播放器 有用</span>\n\n<span><span>#</span><span>ifndef</span> <span>CPPCLIONPROJECT_SAFE_QUEUE_TOO_H</span></span>\n<span><span>#</span><span>define</span> <span>CPPCLIONPROJECT_SAFE_QUEUE_TOO_H</span></span>\n\n<span><span>#</span><span>endif</span> <span>//CPPCLIONPROJECT_SAFE_QUEUE_TOO_H</span></span>\n\n<span><span>#</span><span>pragma</span> <span>once </span><span>// 防止重复写 include 的控制</span></span>\n\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span><span>#</span><span>include</span> <span>&lt;string></span></span>\n<span><span>#</span><span>include</span> <span>&lt;pthread.h></span></span>\n<span><span>#</span><span>include</span> <span>&lt;string></span></span>\n<span><span>#</span><span>include</span> <span>&lt;queue></span></span>\n\nusing namespace std<span>;</span>\n\n<span>// 定义模版函数 int double float == Java的泛型</span>\ntemplate<span>&lt;</span>typename T<span>></span>\n\nclass SafeQueueClass <span>{</span>\nprivate<span>:</span>\n    queue<span>&lt;</span>T<span>></span> queue<span>;</span> <span>// 定义队列</span>\n    <span>pthread_mutex_t</span>  mutex<span>;</span> <span>// 定义互斥锁（不允许有野指针）</span>\n    <span>pthread_cond_t</span> cond<span>;</span> <span>// 条件变量，为了实现 等待 读取 等功能 （不允许有野指针）</span>\n\npublic<span>:</span>\n    <span>SafeQueueClass</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 初始化 互斥锁</span>\n        <span>pthread_mutex_init</span><span>(</span><span>&amp;</span>mutex<span>,</span> <span>0</span><span>)</span><span>;</span>\n\n        <span>// 初始化 条件变量</span>\n        <span>pthread_cond_init</span><span>(</span><span>&amp;</span>cond<span>,</span> <span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>~</span><span>SafeQueueClass</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 回收 互斥锁</span>\n        <span>pthread_mutex_destroy</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span>\n\n        <span>// 回收 条件变量</span>\n        <span>pthread_cond_destroy</span><span>(</span><span>&amp;</span>cond<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// TODO 加入到队列中（进行生成）</span>\n    <span>void</span> <span>add</span><span>(</span>T t<span>)</span> <span>{</span>\n        <span>// 为了安全 加锁</span>\n        <span>pthread_mutex_lock</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span>\n\n        queue<span>.</span><span>push</span><span>(</span>t<span>)</span><span>;</span> <span>// 把数据加入到队列中</span>\n\n        <span>// 告诉消费者，我已经生产好了</span>\n        <span>// pthread_cond_signal(&amp;cond) // Java notify 单个的</span>\n        <span>pthread_cond_broadcast</span><span>(</span><span>&amp;</span>cond<span>)</span><span>;</span> <span>// Java notifyAll 所有的的</span>\n\n        cout <span>&lt;&lt;</span> <span>\"add queue.push 我已经notifyAll所有等待线程了\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n\n        <span>// 解锁</span>\n        <span>pthread_mutex_unlock</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// TODO 从队列中获取（进行消费） 外面的人消费 你可以直接返回，你也可以采用引用</span>\n    <span>void</span> <span>get</span><span>(</span>T <span>&amp;</span> t<span>)</span> <span>{</span>\n        <span>// 为了安全 加锁</span>\n        <span>pthread_mutex_lock</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span>\n\n        <span>while</span> <span>(</span>queue<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            cout <span>&lt;&lt;</span> <span>\"get empty 我已经乖乖等待中..\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n            <span>pthread_cond_wait</span><span>(</span><span>&amp;</span>cond<span>,</span> <span>&amp;</span>mutex<span>)</span><span>;</span> <span>// 相当于 Java的 wait 等待了[有可能被系统唤醒]</span>\n        <span>}</span>\n\n        <span>// 证明被唤醒了</span>\n        t <span>=</span> queue<span>.</span><span>front</span><span>(</span><span>)</span><span>;</span> <span>// 得到 队列中的元素数据 仅此而已</span>\n        queue<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span> <span>// 删除元素</span>\n\n        <span>// 解锁</span>\n        <span>pthread_mutex_unlock</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>// TODO C++ 条件变量+互斥锁 == Java版本的（notify 与 wait 操作）</span>\n\n<span><span>#</span><span>pragma</span> <span>once</span></span>\n\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n\n<span><span>#</span><span>include</span> <span>\"safe_queue_too.h\"</span></span>\n<span>using</span> <span>namespace</span> std<span>;</span>\nSafeQueueClass<span>&lt;</span><span>int</span><span>></span> sq<span>;</span>\n\n<span>// TODO 模拟演示 消费者</span>\n<span>void</span> <span>*</span> <span>getMethod</span><span>(</span><span>void</span> <span>*</span><span>)</span> <span>{</span>\n    <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n        <span>printf</span><span>(</span><span>\"getMethod\\n\"</span><span>)</span><span>;</span>\n\n        <span>int</span>  value<span>;</span>\n        sq<span>.</span><span>get</span><span>(</span>value<span>)</span><span>;</span>\n        <span>printf</span><span>(</span><span>\"消费者get 得到的数据:%d\\n\"</span><span>,</span> value<span>)</span><span>;</span>\n\n        <span>// 你只要传入 -1 就结束当前循环</span>\n        <span>if</span> <span>(</span><span>-</span><span>1</span> <span>==</span> value<span>)</span> <span>{</span>\n            <span>printf</span><span>(</span><span>\"消费者get 全部执行完毕\\n\"</span><span>)</span><span>;</span>\n            <span>break</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n\n<span>// TODO 模拟演示 生产者</span>\n<span>void</span> <span>*</span> <span>setMethod</span><span>(</span><span>void</span> <span>*</span><span>)</span> <span>{</span>\n    <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n        <span>printf</span><span>(</span><span>\"setMethod\\n\"</span><span>)</span><span>;</span>\n\n        <span>int</span> value<span>;</span>\n        <span>printf</span><span>(</span><span>\"请输入你要生成的信息:\\n\"</span><span>)</span><span>;</span>\n        cin <span>>></span> value<span>;</span>\n\n        <span>// 你只要传入 -1 就结束当前循环</span>\n        <span>if</span> <span>(</span><span>-</span><span>1</span> <span>==</span> value<span>)</span> <span>{</span>\n            sq<span>.</span><span>add</span><span>(</span>value<span>)</span><span>;</span> <span>// 为了让消费者 可以结束循环</span>\n            <span>printf</span><span>(</span><span>\"消费者get 全部执行完毕\\n\"</span><span>)</span><span>;</span>\n            <span>break</span><span>;</span>\n        <span>}</span>\n\n        sq<span>.</span><span>add</span><span>(</span>value<span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    pthread_t pthreadGet<span>;</span>\n    <span>pthread_create</span><span>(</span><span>&amp;</span>pthreadGet<span>,</span> <span>0</span><span>,</span> getMethod<span>,</span> <span>0</span><span>)</span><span>;</span>\n    <span>// pthread_join(pthreadGet, 0); 不能这样写，否则，下面的代码，可能无法有机会执行</span>\n\n    pthread_t pthreadSet<span>;</span>\n    <span>pthread_create</span><span>(</span><span>&amp;</span>pthreadSet<span>,</span> <span>0</span><span>,</span> setMethod<span>,</span> <span>0</span><span>)</span><span>;</span>\n\n\n    <span>pthread_join</span><span>(</span>pthreadGet<span>,</span> <span>0</span><span>)</span><span>;</span>\n\n    <span>pthread_join</span><span>(</span>pthreadSet<span>,</span> <span>0</span><span>)</span><span>;</span>\n\n\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"智能指针\" tabindex=\"-1\"> 智能指针</h3>\n<ol>\n<li>智能指针自动释放堆区的对象，无需开发者写<code>delete</code></li>\n<li>智能指针的类型：<code>shared_ptr</code>,<code>weak_ptr</code>,<code>unique_ptr</code></li>\n</ol>\n<h4 id=\"智能指针的使用\" tabindex=\"-1\"> 智能指针的使用</h4>\n<ul>\n<li><code>shared_ptr</code></li>\n</ul>\n<div><pre><code><span>// TODO 智能指针初探 内部机制原理</span>\n\n<span>// 在真实开发过程中，才能体系智能指针的用途，否则写demo无法体现，为什么？</span>\n<span>// 因为真实开发过程中，很很多的代码，可能会导致你忘记写 delete 对象；</span>\n<span>// new 对象  我就马上 加入到 智能指针  我就不会忘记了</span>\n\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span><span>#</span><span>include</span> <span>&lt;memory></span> <span>// 智能指针的头文件引入</span></span>\n<span>using</span> <span>namespace</span> std<span>;</span>\n\n<span>class</span> <span>Person</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>~</span><span>Person</span><span>(</span><span>)</span> <span>{</span>\n        cout <span>&lt;&lt;</span> <span>\"Person 析构函数\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    std<span>::</span>cout <span>&lt;&lt;</span> <span>\"C++最后一节课\"</span> <span>&lt;&lt;</span> std<span>::</span>endl<span>;</span>\n\n    Person <span>*</span> person1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span> <span>// 堆区开辟</span>\n    Person <span>*</span> person2 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span> <span>// 堆区开辟</span>\n\n    <span>// 以前：</span>\n    <span>// delete person1; 忘记写了，怎么办，非常严重的问题，没法释放</span>\n\n    <span>// 现在：</span>\n    <span>// shared_ptr&lt;Person> sharedPtr1(person1); // 智能指针帮你释放堆区开辟的 --> Person 析构函数</span>\n\n    <span>/*\n     *\n     *\n     *   10000行代码\n     *\n     *\n     *\n     */</span>\n    <span>// 最后，就忘记给人家 delete person1</span>\n    <span>// 如果 加入到 智能指针，我就不用管了</span>\n\n    shared_ptr<span>&lt;</span>Person<span>></span> <span>sharedPtr1</span><span>(</span>person1<span>)</span><span>;</span> <span>// 栈区开辟sharedPtr1， 加1 等于1 引用计数</span>\n    shared_ptr<span>&lt;</span>Person<span>></span> <span>sharedPtr2</span><span>(</span>person2<span>)</span><span>;</span> <span>// 栈区开辟sharedPtr2  加1 等于1 引用计数</span>\n\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n<span>// main函数弹栈，会释放 所有的栈成员 sharedPtr1 调用 sharedPtr1析构函数 减1 等于0  直接释放person1</span>\n<span>// main函数弹栈，会释放 所有的栈成员 sharedPtr2 调用 sharedPtr2析构函数 减1 等于0  直接释放person2</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>\n<li>\n<p><code>shared_ptr</code>相互依赖的问题</p>\n</li>\n<li>\n<p>解决相互依赖的问题，使用<code>weak_ptr</code> 智能指针</p>\n</li>\n</ul>\n<div><pre><code><span>// TODO 智能指针 使用频率高不高  1  2</span>\n<span>// 智能指针 有循环依赖的问题，你要用就用好，不要用的复杂，循环依赖的问题</span>\n<span>// TODO 智能指针 循环依赖问题，故意制作</span>\n\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span><span>#</span><span>include</span> <span>&lt;memory></span> <span>// 智能指针的头文件引入</span></span>\n<span>using</span> <span>namespace</span> std<span>;</span>\n\n<span>class</span> <span>Person2</span><span>;</span> <span>// 先声明 Person2 让我们的Person1 直接找到</span>\n\n<span>class</span> <span>Person1</span> <span>{</span>\n<span>public</span><span>:</span>\n    shared_ptr<span>&lt;</span>Person2<span>></span> person2<span>;</span> <span>// Person2智能指针  shared_ptr 引用计数+1</span>\n    <span>~</span><span>Person1</span><span>(</span><span>)</span> <span>{</span>\n        cout <span>&lt;&lt;</span> <span>\"Person1 析构函数\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n\n<span>class</span> <span>Person2</span> <span>{</span>\n<span>public</span><span>:</span>\n    shared_ptr<span>&lt;</span>Person1<span>></span> person1<span>;</span>  <span>// Person1智能指针  shared_ptr 引用计数+1</span>\n    <span>~</span><span>Person2</span><span>(</span><span>)</span> <span>{</span>\n        cout <span>&lt;&lt;</span> <span>\"Person2 析构函数\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    Person1 <span>*</span> person1 <span>=</span> <span>new</span> <span>Person1</span><span>(</span><span>)</span><span>;</span> <span>// 堆区开辟</span>\n    Person2 <span>*</span> person2 <span>=</span> <span>new</span> <span>Person2</span><span>(</span><span>)</span><span>;</span> <span>// 堆区开辟</span>\n\n    shared_ptr<span>&lt;</span>Person1<span>></span> <span>sharedPtr1</span><span>(</span>person1<span>)</span><span>;</span> <span>// +1 = 1</span>\n    shared_ptr<span>&lt;</span>Person2<span>></span> <span>sharedPtr2</span><span>(</span>person2<span>)</span><span>;</span> <span>// +1 = 1</span>\n\n    cout <span>&lt;&lt;</span> <span>\"前 sharedPtr1的引用计数是:\"</span> <span>&lt;&lt;</span> sharedPtr1<span>.</span><span>use_count</span><span>(</span><span>)</span> <span>&lt;&lt;</span> endl<span>;</span>\n    cout <span>&lt;&lt;</span> <span>\"前 sharedPtr2的引用计数是:\"</span> <span>&lt;&lt;</span> sharedPtr2<span>.</span><span>use_count</span><span>(</span><span>)</span> <span>&lt;&lt;</span> endl<span>;</span>\n\n    <span>// 给Person2智能指针赋值</span>\n    person1<span>-></span>person2 <span>=</span> sharedPtr2<span>;</span>\n    <span>// 给Person1智能指针赋值</span>\n    person2<span>-></span>person1 <span>=</span> sharedPtr1<span>;</span>\n\n    cout <span>&lt;&lt;</span> <span>\"后 sharedPtr1的引用计数是:\"</span> <span>&lt;&lt;</span> sharedPtr1<span>.</span><span>use_count</span><span>(</span><span>)</span> <span>&lt;&lt;</span> endl<span>;</span>\n    cout <span>&lt;&lt;</span> <span>\"后 sharedPtr2的引用计数是:\"</span> <span>&lt;&lt;</span> sharedPtr2<span>.</span><span>use_count</span><span>(</span><span>)</span> <span>&lt;&lt;</span> endl<span>;</span>\n\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span> <span>// 减1 = 0 释放对象</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>\n<li><code>weak_ptr</code>的使用</li>\n</ul>\n<div><pre><code><span>// TODO 智能指针 解决循环依赖的问题  weak 智能指针 没有引用计数</span>\n\n<span>// C++ 11后 推出智能指针，为什么要推出？  JVM非常厉害，完全不用管对象的回收的问题</span>\n\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span><span>#</span><span>include</span> <span>&lt;memory></span> <span>// 智能指针的头文件引入</span></span>\n<span>using</span> <span>namespace</span> std<span>;</span>\n\n<span>class</span> <span>Person2</span><span>;</span> <span>// 先声明 Person2 让我们的Person1 直接找到</span>\n\n<span>class</span> <span>Person1</span> <span>{</span>\n<span>public</span><span>:</span>\n    weak_ptr<span>&lt;</span>Person2<span>></span> person2<span>;</span> <span>// Person2智能指针  没有引用计数 无法+1</span>\n    <span>~</span><span>Person1</span><span>(</span><span>)</span> <span>{</span>\n        cout <span>&lt;&lt;</span> <span>\"Person1 析构函数\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n\n<span>class</span> <span>Person2</span> <span>{</span>\n<span>public</span><span>:</span>\n    weak_ptr<span>&lt;</span>Person1<span>></span> person1<span>;</span>  <span>// Person1智能指针  没有引用计数 无法+1</span>\n    <span>~</span><span>Person2</span><span>(</span><span>)</span> <span>{</span>\n        cout <span>&lt;&lt;</span> <span>\"Person2 析构函数\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    Person1 <span>*</span> person1 <span>=</span> <span>new</span> <span>Person1</span><span>(</span><span>)</span><span>;</span> <span>// 堆区开辟</span>\n    Person2 <span>*</span> person2 <span>=</span> <span>new</span> <span>Person2</span><span>(</span><span>)</span><span>;</span> <span>// 堆区开辟</span>\n\n    shared_ptr<span>&lt;</span>Person1<span>></span> <span>sharedPtr1</span><span>(</span>person1<span>)</span><span>;</span> <span>// +1 = 1</span>\n    shared_ptr<span>&lt;</span>Person2<span>></span> <span>sharedPtr2</span><span>(</span>person2<span>)</span><span>;</span> <span>// +1 = 1</span>\n\n    cout <span>&lt;&lt;</span> <span>\"前 sharedPtr1的引用计数是:\"</span> <span>&lt;&lt;</span> sharedPtr1<span>.</span><span>use_count</span><span>(</span><span>)</span> <span>&lt;&lt;</span> endl<span>;</span>\n    cout <span>&lt;&lt;</span> <span>\"前 sharedPtr2的引用计数是:\"</span> <span>&lt;&lt;</span> sharedPtr2<span>.</span><span>use_count</span><span>(</span><span>)</span> <span>&lt;&lt;</span> endl<span>;</span>\n\n    <span>// 给Person2智能指针赋值</span>\n    person1<span>-></span>person2 <span>=</span> sharedPtr2<span>;</span>\n    <span>// 给Person1智能指针赋值</span>\n    person2<span>-></span>person1 <span>=</span> sharedPtr1<span>;</span>\n\n    cout <span>&lt;&lt;</span> <span>\"后 sharedPtr1的引用计数是:\"</span> <span>&lt;&lt;</span> sharedPtr1<span>.</span><span>use_count</span><span>(</span><span>)</span> <span>&lt;&lt;</span> endl<span>;</span>\n    cout <span>&lt;&lt;</span> <span>\"后 sharedPtr2的引用计数是:\"</span> <span>&lt;&lt;</span> sharedPtr2<span>.</span><span>use_count</span><span>(</span><span>)</span> <span>&lt;&lt;</span> endl<span>;</span>\n\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span> <span>// 减1 = 0 释放对象</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>\n<li><code>unique</code>的使用</li>\n</ul>\n<div><pre><code><span>// TODO unique 智能指针  设计的够简单，每一那么多功能  [独占式智能指针]</span>\n\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span><span>#</span><span>include</span> <span>&lt;memory></span> <span>// 智能指针的头文件引入</span></span>\n\n<span>class</span> <span>Person</span> <span>{</span><span>}</span><span>;</span>\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    Person <span>*</span> person1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>\n    Person <span>*</span> person2 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>\n\n    std<span>::</span>unique_ptr<span>&lt;</span>Person<span>></span> <span>uniquePtr1</span><span>(</span>person1<span>)</span><span>;</span>\n\n    <span>// 严格禁止</span>\n    <span>// std::unique_ptr&lt;Person> uniquePtr2 = uniquePtr1;  unique不允许，因为是独占的</span>\n\n    <span>// shared_ptr 是可以的，会造成隐患问题</span>\n\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"手写智能指针\" tabindex=\"-1\"> 手写智能指针</h3>\n<div><pre><code><span>// TODO  手写智能指针</span>\n\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span><span>#</span><span>include</span> <span>&lt;memory></span> <span>// 智能指针的头文件引入</span></span>\n\n<span>using</span> <span>namespace</span> std<span>;</span>\n\n<span>class</span> <span>Person</span> <span>{</span><span>}</span><span>;</span>\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    Person <span>*</span> person1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>\n    <span>// Person * person2 = new Person();</span>\n\n    <span>// shared_ptr&lt;Person> sharedPtr0;</span>\n\n    shared_ptr<span>&lt;</span>Person<span>></span> <span>sharedPtr1</span><span>(</span>person1<span>)</span><span>;</span> <span>// +1 引用计数</span>\n\n    <span>// 第一种情况 会调用拷贝构造函数</span>\n    <span>// shard_ptr智能指针的特性</span>\n    <span>// shared_ptr&lt;Person> sharedPtr2 = sharedPtr1;  // +1 再引用计数  不会调用构造函数，只能执行拷贝构造函数</span>\n\n    <span>// 第二种情况 不会调用拷贝构造函数</span>\n    shared_ptr<span>&lt;</span>Person<span>></span> sharedPtr2<span>;</span>  <span>// +1 再引用计数   先构造函数 开辟sharedPtr2对象</span>\n\n    <span>// 给sharedPtr2对象 从新赋值</span>\n    sharedPtr2 <span>=</span> sharedPtr1<span>;</span> <span>// 自定义 =号运算符重载</span>\n\n\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n<span>// main函数弹栈 sharedPtr1栈成员  ---> 析构函数 --等于0 就释放对象</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span><span>#</span><span>ifndef</span> <span>CPPCLIONPROJECT_CUSTOMPTR_H</span></span>\n<span><span>#</span><span>define</span> <span>CPPCLIONPROJECT_CUSTOMPTR_H</span></span>\n\n<span><span>#</span><span>pragma</span> <span>once</span></span>\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span><span>#</span><span>include</span> <span>&lt;memory></span> <span>// 智能指针的</span></span>\n<span>using</span> <span>namespace</span> std<span>;</span>\n\n<span>template</span><span>&lt;</span><span>typename</span> <span>T</span><span>></span>\n<span>class</span> <span>Ptr</span> <span>{</span>\n<span>private</span><span>:</span>\n    T <span>*</span> object<span>;</span> <span>// 用于智能指针指向管理的对象  Person Student</span>\n    <span>int</span> <span>*</span> count<span>;</span> <span>// 引用计数</span>\n\n<span>public</span><span>:</span>\n    <span>Ptr</span><span>(</span><span>)</span> <span>{</span>\n        count <span>=</span> <span>new</span> <span>int</span> <span>(</span><span>1</span><span>)</span><span>;</span> <span>// new 的对象 必须 *指针   【new只是为了后面操作方便】</span>\n        object <span>=</span> <span>0</span><span>;</span> <span>// 因为你没有给他对象呀，人家也没有对象呀，没办法</span>\n    <span>}</span>\n\n    <span>// t = Person Student</span>\n    <span>Ptr</span><span>(</span>T <span>*</span> t<span>)</span> <span>:</span><span>object</span><span>(</span>t<span>)</span> <span>{</span>\n        <span>// 只有你存入对象，那么引用计数为1，这个是很合理的</span>\n        count <span>=</span> <span>new</span> <span>int</span> <span>(</span><span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// 析构函数</span>\n    <span>~</span><span>Ptr</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 引用计数减1，为0标识可以释放object了</span>\n        <span>if</span> <span>(</span><span>--</span><span>(</span><span>*</span>count<span>)</span> <span>==</span><span>0</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>object<span>)</span> <span>{</span>\n                <span>delete</span> object<span>;</span>\n            <span>}</span>\n            <span>// 归零</span>\n            <span>delete</span> count<span>;</span>\n            object <span>=</span> <span>0</span><span>;</span>\n            count <span>=</span> <span>0</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>// 拷贝构造函数</span>\n    <span>Ptr</span><span>(</span><span>const</span> Ptr<span>&lt;</span>T<span>></span> <span>&amp;</span> p<span>)</span> <span>{</span>\n        cout <span>&lt;&lt;</span> <span>\"拷贝构造函数\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n\n        <span>// sharedPtr1 == p 的引用计数 +1  = 2</span>\n        <span>++</span><span>(</span><span>*</span>p<span>.</span>count<span>)</span><span>;</span>\n\n        object <span>=</span> p<span>.</span>object<span>;</span>\n        count <span>=</span> p<span>.</span>count<span>;</span> <span>// 最终是不是 p.count==2 给 count==2</span>\n    <span>}</span>\n\n    <span>// 自定义 =号运算符重载</span>\n    Ptr<span>&lt;</span>T<span>></span> <span>&amp;</span> <span>operator</span> <span>=</span> <span>(</span><span>const</span> Ptr<span>&lt;</span>T<span>></span> <span>&amp;</span> p<span>)</span> <span>{</span>\n        cout <span>&lt;&lt;</span> <span>\"=号运算符重载\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n\n        <span>++</span><span>(</span><span>*</span>p<span>.</span>count<span>)</span><span>;</span>\n\n        <span>// 这个点非常绕  跳过  看不懂没有关系，后面专门解释 (配合代码)</span>\n        <span>if</span> <span>(</span><span>--</span><span>(</span><span>*</span>count<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>object<span>)</span> <span>{</span>\n                <span>delete</span> object<span>;</span>\n            <span>}</span>\n            <span>delete</span> count<span>;</span>\n        <span>}</span>\n\n        object <span>=</span> p<span>.</span>object<span>;</span>\n        count <span>=</span> p<span>.</span>count<span>;</span>\n        <span>return</span> <span>*</span><span>this</span><span>;</span> <span>// 运算符重载的返回</span>\n    <span>}</span>\n\n    <span>// 返回引用计数的数值</span>\n    <span>int</span> <span>use_count</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>*</span><span>this</span><span>-></span>count<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n\n\n<span><span>#</span><span>endif</span> <span>//CPPCLIONPROJECT_CUSTOMPTR_H</span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"手写智能指针2\" tabindex=\"-1\"> 手写智能指针2</h3>\n<div><pre><code><span>// TODO  手写智能指针 2</span>\n\n<span><span>#</span><span>include</span> <span>\"CustomPtr.h\"</span></span>\n\n<span>class</span> <span>Student</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>~</span><span>Student</span><span>(</span><span>)</span> <span>{</span>\n        cout <span>&lt;&lt;</span> <span>\"析构函数 释放Student\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n\n<span>// TODO 智能指针内置的</span>\n<span>void</span> <span>action</span><span>(</span><span>)</span> <span>{</span>\n    Student <span>*</span>student1 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>)</span><span>;</span>\n    Student <span>*</span>student2 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>)</span><span>;</span>\n\n    <span>// TODO 第一种情况</span>\n    <span>/*shared_ptr&lt;Student> sharedPtr1(student1);\n    shared_ptr&lt;Student> sharedPtr2(student2);*/</span>\n\n    <span>// TODO 第二种情况</span>\n    <span>/*shared_ptr&lt;Student> sharedPtr1 (student1);\n    shared_ptr&lt;Student> sharedPtr2 = sharedPtr1;*/</span>\n\n    <span>// TODO 通用的打印</span>\n    <span>/*cout &lt;&lt; \"智能指针内置的 sharedPtr1:\" &lt;&lt; sharedPtr1.use_count() &lt;&lt; endl;\n    cout &lt;&lt; \"智能指针内置的 sharedPtr2:\" &lt;&lt; sharedPtr2.use_count() &lt;&lt; endl;*/</span>\n<span>}</span>\n\n<span>// TODO  手写的智能指针</span>\n<span>void</span> <span>action2</span><span>(</span><span>)</span> <span>{</span>\n    Student <span>*</span>student1 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>)</span><span>;</span>\n    Student <span>*</span>student2 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>)</span><span>;</span>\n\n    <span>// TODO 第一种情况</span>\n    <span>/*Ptr&lt;Student> sharedPtr1(student1);\n    Ptr&lt;Student> sharedPtr2(student2);*/</span>\n\n    <span>// TODO 第二种情况</span>\n    <span>/*Ptr&lt;Student> sharedPtr1 (student1);\n    Ptr&lt;Student> sharedPtr2 = sharedPtr1;*/</span>\n\n    <span>// TODO 第二种情况</span>\n    <span>// TODO 情况一</span>\n    <span>/*Ptr&lt;Student> sharedPtr1 (student1); // sharedPtr1构建对象\n    Ptr&lt;Student> sharedPtr2; // sharedPtr2也会构建对象， 此对象指向了object 与 count，必须释放\n\n    // 在你写下面这个之前，我必须是发 sharedPtr2 的所有 object count 全部释放\n    // sharedPtr2完全释放干净后，我才放心然你赋值 sharedPtr2 = sharedPtr1\n    sharedPtr2 = sharedPtr1;*/</span>\n\n\n    <span>// TODO 情况二</span>\n    Ptr<span>&lt;</span>Student<span>></span> <span>sharedPtr1</span> <span>(</span>student1<span>)</span><span>;</span> <span>// sharedPtr1构建对象</span>\n    <span>// student2 成为野对象（每一被智能指针管理的对象 称为 野对象）</span>\n    Ptr<span>&lt;</span>Student<span>></span> <span>sharedPtr2</span> <span>(</span>student2<span>)</span><span>;</span>\n\n    <span>// 在你写下面这个之前，我必须是发 sharedPtr2 的 的 student2 全部释放成功</span>\n    <span>// sharedPtr2完全释放干净后,才放心然你赋值 sharedPtr2 = sharedPtr1</span>\n\n    sharedPtr2 <span>=</span> sharedPtr1<span>;</span>\n\n    <span>// delete student2; // 如果--哪些逻辑不写，就必须手动是否 student2</span>\n\n    <span>// TODO 通用的打印</span>\n    cout <span>&lt;&lt;</span> <span>\"手写的智能指针 sharedPtr1:\"</span> <span>&lt;&lt;</span> sharedPtr1<span>.</span><span>use_count</span><span>(</span><span>)</span> <span>&lt;&lt;</span> endl<span>;</span>\n    cout <span>&lt;&lt;</span> <span>\"手写的智能指针 sharedPtr2:\"</span> <span>&lt;&lt;</span> sharedPtr2<span>.</span><span>use_count</span><span>(</span><span>)</span> <span>&lt;&lt;</span> endl<span>;</span>\n<span>}</span>\n\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    cout <span>&lt;&lt;</span> <span>\"下面是 C++内置智能指针 ===========\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>// action();</span>\n    cout <span>&lt;&lt;</span> endl<span>;</span>\n\n    cout <span>&lt;&lt;</span> <span>\"下面是 自定义的智能指针 ===========\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>action2</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"类型转换\" tabindex=\"-1\"> 类型转换</h3>\n<h4 id=\"const-cast\" tabindex=\"-1\"> const_cast</h4>\n<div><pre><code><span>// 3.四种类型转换。 const_cast     const修饰的 都可以去转换</span>\n\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n\n<span>using</span> <span>namespace</span> std<span>;</span>\n\n<span>class</span> <span>Person</span> <span>{</span>\n<span>public</span><span>:</span>\n    string name <span>=</span> <span>\"default\"</span><span>;</span>\n<span>}</span><span>;</span>\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    <span>const</span> Person <span>*</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>\n    <span>// p1->name = \"Derry\"; // 报错：常量指针，不写修改值</span>\n\n    Person <span>*</span> p2 <span>=</span> <span><span>const_cast</span><span><span>&lt;</span>Person <span>*</span><span>></span></span></span><span>(</span>p1<span>)</span><span>;</span> <span>// 转成 非常量指针</span>\n    p2<span>-></span>name <span>=</span> <span>\"Derry\"</span><span>;</span>\n\n    cout <span>&lt;&lt;</span> p1<span>-></span>name <span>&lt;&lt;</span> endl<span>;</span> <span>// Derry</span>\n\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id=\"static-cast\" tabindex=\"-1\"> static_cast</h4>\n<div><pre><code><span>// 3.四种类型转换。 static_cast   指针相关的操作 可以用 static_cast</span>\n\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span>using</span> <span>namespace</span> std<span>;</span>\n\n<span>class</span> <span>FuClass</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>void</span> <span>show</span><span>(</span><span>)</span> <span>{</span>\n        cout <span>&lt;&lt;</span> <span>\"fu show\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n\n<span>class</span> <span>ZiClass</span>  <span>:</span> <span><span>public</span> <span>FuClass</span></span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>void</span> <span>show</span><span>(</span><span>)</span> <span>{</span>\n        cout <span>&lt;&lt;</span> <span>\"zi show\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    <span>int</span> n <span>=</span> <span>88</span><span>;</span>\n    <span>void</span> <span>*</span> pVoid <span>=</span> <span>&amp;</span>n<span>;</span>\n    <span>int</span> <span>*</span> number <span>=</span> <span><span>static_cast</span><span><span>&lt;</span><span>int</span> <span>*</span><span>></span></span></span><span>(</span>pVoid<span>)</span><span>;</span>\n    cout <span>&lt;&lt;</span> <span>*</span>number <span>&lt;&lt;</span> endl<span>;</span>\n\n    <span>// ====================</span>\n\n    FuClass <span>*</span> fuClass <span>=</span> <span>new</span> FuClass<span>;</span>\n    <span>// fuClass->show();</span>\n\n    <span>// static_cast(编译期) 看左边 ZiClass *</span>\n    ZiClass <span>*</span> ziClass <span>=</span> <span><span>static_cast</span><span><span>&lt;</span>ZiClass <span>*</span><span>></span></span></span><span>(</span>fuClass<span>)</span><span>;</span>\n    ziClass<span>-></span><span>show</span><span>(</span><span>)</span><span>;</span>\n\n    <span>delete</span> fuClass<span>;</span> <span>// 回收规则：一定是谁new了，我就delete谁</span>\n\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id=\"dynamic-cast\" tabindex=\"-1\"> dynamic_cast</h4>\n<div><pre><code><span>// 3.四种类型转换。 dynamic 字符类多态 运行期 转换</span>\n\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span>using</span> <span>namespace</span> std<span>;</span>\n\n<span>class</span> <span>FuClass</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>// 动态转换必须让父类成为虚函数</span>\n    <span>virtual</span> <span>void</span> <span>show</span><span>(</span><span>)</span> <span>{</span>\n        cout <span>&lt;&lt;</span> <span>\"fu show\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n\n<span>class</span> <span>ZiClass</span>  <span>:</span> <span><span>public</span> <span>FuClass</span></span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>void</span> <span>show</span><span>(</span><span>)</span> <span>{</span>\n        cout <span>&lt;&lt;</span> <span>\"zi show\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 动态类型转换的时候，在运行期 由于fuClass 是new 父类的，已成定局，就不能转换子类</span>\n    <span>// FuClass * fuClass = new FuClass(); // 失败</span>\n\n    FuClass <span>*</span> fuClass <span>=</span> <span>new</span> ZiClass<span>;</span> <span>// 已成定局 是子类</span>\n    ZiClass <span>*</span> ziClass <span>=</span> <span><span>dynamic_cast</span><span><span>&lt;</span>ZiClass <span>*</span><span>></span></span></span><span>(</span>fuClass<span>)</span><span>;</span>\n\n    <span>// TODO 子类转父类不行的，同学们自己去试一试</span>\n\n    <span>// 动态转换是有返回值， null 转换失败</span>\n    <span>if</span> <span>(</span>ziClass<span>)</span> <span>{</span> <span>// ziClass != null</span>\n        cout <span>&lt;&lt;</span> <span>\"恭喜，转换成功 \"</span> <span>;</span>\n        ziClass<span>-></span><span>show</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        cout <span>&lt;&lt;</span> <span>\"不恭喜 转换失败\"</span> <span>&lt;&lt;</span> endl <span>;</span>\n    <span>}</span>\n\n\n\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id=\"reinterpret-cast\" tabindex=\"-1\"> reinterpret_cast</h4>\n<div><pre><code><span>// 3.四种类型转换。 reinterpret_cast 强制转换 比 static_cast要强大， static_cast能够做的事情，</span>\n<span>// reinterpret_cast强制转换都可以，同时并且附加 新功能</span>\n\n<span><span>#</span><span>pragma</span> <span>once</span></span>\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n\n<span>using</span> <span>namespace</span> std<span>;</span>\n\n<span>class</span> <span>DerryPlayer</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>void</span> <span>show</span><span>(</span><span>)</span> <span>{</span>\n        cout <span>&lt;&lt;</span> <span>\"DerryPlayer\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    DerryPlayer <span>*</span> derryPlayer <span>=</span> <span>new</span> <span>DerryPlayer</span><span>(</span><span>)</span><span>;</span>\n    <span>long</span> playerValue <span>=</span> <span><span>reinterpret_cast</span><span><span>&lt;</span><span>long</span><span>></span></span></span><span>(</span>derryPlayer<span>)</span><span>;</span> <span>// 把对象变成数值</span>\n\n    <span>// 通过数值 变成对象</span>\n    DerryPlayer <span>*</span> derryPlayer2 <span>=</span> <span><span>reinterpret_cast</span><span><span>&lt;</span>DerryPlayer <span>*</span><span>></span></span></span><span>(</span>playerValue<span>)</span><span>;</span>\n    derryPlayer2<span>-></span><span>show</span><span>(</span><span>)</span><span>;</span>\n\n    <span>printf</span><span>(</span><span>\"derryPlayer:%p\\n\"</span><span>,</span> derryPlayer<span>)</span><span>;</span>\n    <span>printf</span><span>(</span><span>\"derryPlayer2:%p\\n\"</span><span>,</span> derryPlayer2<span>)</span><span>;</span>\n\n    <span>// 前面的只是：为什么不一样：因为指针存放地址，同时指针有自己的地址，而你打印了自己的的地址，能一样？</span>\n    <span>printf</span><span>(</span><span>\"derryPlayer:%p\\n\"</span><span>,</span> <span>&amp;</span>derryPlayer<span>)</span><span>;</span>\n    <span>printf</span><span>(</span><span>\"derryPlayer2:%p\\n\"</span><span>,</span> <span>&amp;</span>derryPlayer2<span>)</span><span>;</span>\n\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id=\"nullptr\" tabindex=\"-1\"> nullptr</h4>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span>using</span> <span>namespace</span> std<span>;</span>\n\n<span>void</span> <span>show</span><span>(</span><span>int</span> <span>*</span> i<span>)</span> <span>{</span>\n    cout <span>&lt;&lt;</span> <span>\" show(int * i) \"</span> <span>&lt;&lt;</span> endl<span>;</span>\n<span>}</span>\n\n<span>void</span> <span>show</span><span>(</span><span>int</span>  i<span>)</span> <span>{</span>\n    cout <span>&lt;&lt;</span> <span>\" show(int  i) \"</span> <span>&lt;&lt;</span> endl<span>;</span>\n<span>}</span>\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    <span>show</span><span>(</span><span>9</span><span>)</span><span>;</span>\n\n    <span>show</span><span>(</span><span>nullptr</span><span>)</span><span>;</span> <span>// C++11 后的特性： 原本本意代替NULL，除了代替NULL，还有此功能</span>\n\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"预处理器\" tabindex=\"-1\"> 预处理器</h3>\n<h4 id=\"if-elif-endif\" tabindex=\"-1\"> <code>#if</code> <code>#elif</code> <code>#endif</code></h4>\n<div><pre><code><span>// TODO 预处理器不是编译器，预处理器主要完成文本替换的操作（文本替换，以后专门在Linux中去讲），预处理器都是用 #xxx 的写法，并不是注释哦</span>\n\n<span>/*\n                                #include  导入头文件\n                                #if       if判断操作  【if的范畴 必须endif】\n                                #elif     else if\n                                #else     else\n                                #endif    结束if\n          #define   定义一个宏\n          #ifdef    如果定义了这个宏 【if的范畴 必须endif】\n          #ifndef   如果没有定义这个宏 【if的范畴 必须endif】\n          #undef    取消宏定义\n          #pragma   设定编译器的状态\n */</span>\n\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span>using</span> <span>namespace</span> std<span>;</span>\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    <span>// std::cout &lt;&lt; \"宏\" &lt;&lt; std::endl;</span>\n\n<span><span>#</span><span>if</span> <span><span>1</span> </span><span>// if</span></span>\n    cout <span>&lt;&lt;</span>  <span>\"真\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n\n<span><span>#</span><span>elif</span> <span><span>0</span> </span><span>// else if</span></span>\n    cout <span>&lt;&lt;</span>  <span>\"假\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n\n<span><span>#</span><span>else</span></span>\n    cout <span>&lt;&lt;</span> <span>\"都不满足\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n\n<span><span>#</span><span>endif</span> <span>// 结束if</span></span>\n    cout <span>&lt;&lt;</span> <span>\"结束if\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>#ifndef</code> <code>#define</code></p>\n<div><pre><code><span><span>#</span><span>ifndef</span> <span>CLIONCPPPROJECT_T2_H </span><span>// 如果没有定义这个宏  解决循环拷贝的问题</span></span>\n<span><span>#</span><span>define</span> <span>CLIONCPPPROJECT_T2_H</span> <span>// 我就定义这个宏</span></span>\n\n<span>// 100 行代码</span>\n<span>// 第一次能够进来</span>\n<span>// 第二次  第n此进不来    直接 解决循环拷贝的问题了</span>\n\n<span>// ---------------</span>\n<span><span>#</span><span>ifndef</span> <span>isRelease </span><span>// 如果没有isRelease这个宏</span></span>\n<span><span>#</span><span>define</span> <span>isRelease</span> <span><span>1</span> </span><span>// 是否是正式环境下 【我就定义isRelease这个宏】</span></span>\n\n<span><span>#</span><span>if</span> <span>isRelease <span>==</span> <span>true</span></span></span>\n<span><span>#</span><span>define</span> <span>RELEASE</span> <span>// 正式环境下 定义RELEASE宏</span></span>\n\n<span><span>#</span><span>elif</span> <span>isRelease <span>==</span> <span>false</span></span></span>\n<span><span>#</span><span>define</span> <span>DEBUG</span> <span>// 测试环境下  定义DEBUG宏</span></span>\n\n<span><span>#</span><span>endif</span> <span>// 结束里面的if</span></span>\n<span><span>#</span><span>endif</span> <span>// 结束里面的if</span></span>\n\n<span><span>#</span><span>endif</span> <span>//CLIONCPPPROJECT_T2_H // 结束外面的if</span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span><span>#</span><span>include</span> <span>\"T2.h\"</span></span>\n<span>using</span> <span>namespace</span> std<span>;</span>\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n\n    <span>// if 条件判断</span>\n    <span>// ifdef xxx 是否定义了xxx这个宏</span>\n\n<span><span>#</span><span>ifdef</span> <span>DEBUG </span><span>// 是否定义了DEBUG这个宏</span></span>\n    cout <span>&lt;&lt;</span> <span>\"在测试环境下，迭代功能\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>// 省略 500行 ...</span>\n\n<span><span>#</span><span>else</span> <span>RELEASE</span></span>\n    cout <span>&lt;&lt;</span> <span>\"在正式环境下，功能上下中\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>// 省略 500行 ...</span>\n\n<span><span>#</span><span>endif</span> <span>// 结束IF</span></span>\n\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>#undef</code></p>\n<div><pre><code><span>// 宏的取消 #undef 宏</span>\n\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span>using</span> <span>namespace</span> std<span>;</span>\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    <span>int</span> i <span>=</span> <span>1</span>\n\n<span><span>#</span><span>ifndef</span> <span>DERRY </span><span>// 如果没有定义这个宏</span></span>\n<span><span>#</span><span>define</span> <span>DERRY</span> <span>// 我就定义宏</span></span>\n<span><span>#</span><span>ifdef</span> <span>DERRY </span><span>// 是否定义了这个宏</span></span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>6</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>\n        cout <span>&lt;&lt;</span> <span>\"Derry 1\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>}</span>\n    <span>// 省略 500行 ...</span>\n\n<span><span>#</span><span>ifdef</span> <span>DERRY </span><span>// 是否定义了这个宏</span></span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>6</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>\n        cout <span>&lt;&lt;</span> <span>\"Derry 2\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>}</span>\n    <span>// 省略 500行 ...</span>\n\n<span><span>#</span><span>undef</span> <span>DERRY </span><span>// 取消宏的定义，下面的代码，就没法用这个宏了，相当于：没有定义过DERRY宏</span></span>\n\n<span><span>#</span><span>ifdef</span> <span>DERRY</span></span>\n    cout <span>&lt;&lt;</span> <span>\"你定义了Derry宏\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n<span><span>#</span><span>else</span></span>\n    cout <span>&lt;&lt;</span> <span>\"你没有定义了Derry宏\"</span> <span>&lt;&lt;</span> endl<span>;</span>\n\n<span><span>#</span><span>endif</span></span>\n<span><span>#</span><span>endif</span></span>\n<span><span>#</span><span>endif</span></span>\n<span><span>#</span><span>endif</span></span>\n\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"编辑过程\" tabindex=\"-1\"> 编辑过程</h3>\n<ul>\n<li>预处理(宏展开，宏替换)-&gt;预编译，检查代码-&gt;汇编阶段-&gt;链接阶段(.a, .so)-&gt;生成.exe</li>\n</ul>\n<h3 id=\"宏变量\" tabindex=\"-1\"> 宏变量</h3>\n<div><pre><code><span>// 宏函数 真实开发中：宏函数都是大写</span>\n<span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span>using</span> <span>namespace</span> std<span>;</span>\n\n<span><span>#</span><span>define</span> <span>SHOW</span><span><span>(</span>V<span>)</span> cout <span>&lt;&lt;</span> V <span>&lt;&lt;</span> endl<span>;</span> </span><span>// 参数列表 无需类型  返回值 看不到</span></span>\n<span><span>#</span><span>define</span> <span>ADD</span><span><span>(</span>n1<span>,</span> n2<span>)</span> n1 <span>+</span> n2</span></span>\n<span><span>#</span><span>define</span> <span>CHE</span><span><span>(</span>n1<span>,</span> n2<span>)</span> n1 <span>*</span> n2 </span><span>// 故意制作问题 ，宏函数的注意事项</span></span>\n\n<span>// 复杂的宏函数</span>\n<span><span>#</span><span>define</span> <span>LOGIN</span><span><span>(</span>V<span>)</span> <span>if</span><span>(</span>V<span>==</span><span>1</span><span>)</span> <span>{</span>                         </span><span>\\</span>\n    <span>cout <span>&lt;&lt;</span> </span><span>\"满足 你个货输入的是:\"</span> <span><span>&lt;&lt;</span> V <span>&lt;&lt;</span> endl<span>;</span>        </span><span>\\</span>\n<span><span>}</span> <span>else</span> <span>{</span>                                             </span><span>\\</span>\n    <span>cout <span>&lt;&lt;</span> </span><span>\"不满足 你个货输入的是:\"</span> <span><span>&lt;&lt;</span> V <span>&lt;&lt;</span> endl<span>;</span>       </span><span>\\</span>\n<span><span>}</span> </span><span>// 这个是结尾，不需要加 \\\n</span></span>\n<span>void</span> <span>show</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    <span>SHOW</span><span>(</span><span>8</span><span>)</span><span>;</span>\n    <span>SHOW</span><span>(</span><span>8.8f</span><span>)</span><span>;</span>\n    <span>SHOW</span><span>(</span><span>8.99</span><span>)</span><span>;</span>\n\n    <span>int</span> r <span>=</span> <span>ADD</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>;</span>\n    cout <span>&lt;&lt;</span> r <span>&lt;&lt;</span> endl<span>;</span>\n\n    r <span>=</span> <span>ADD</span><span>(</span><span>1</span><span>+</span><span>1</span><span>,</span> <span>2</span><span>+</span><span>2</span><span>)</span><span>;</span>\n    cout <span>&lt;&lt;</span> r <span>&lt;&lt;</span> endl<span>;</span>\n\n    <span>// r = CHE(1+1, 2+2);</span>\n    r <span>=</span> <span>1</span><span>+</span><span>1</span> <span>*</span> <span>2</span><span>+</span><span>2</span><span>;</span> <span>// 文本替换：1+1 * 2+2  先算乘法  最终等于 5</span>\n    cout <span>&lt;&lt;</span> r <span>&lt;&lt;</span> endl<span>;</span> <span>// 我们认为的是8，   但是打印5</span>\n\n    <span>LOGIN</span><span>(</span><span>0</span><span>)</span><span>;</span>\n    <span>LOGIN</span><span>(</span><span>0</span><span>)</span><span>;</span>\n    <span>LOGIN</span><span>(</span><span>0</span><span>)</span><span>;</span>\n    <span>LOGIN</span><span>(</span><span>0</span><span>)</span><span>;</span>\n    <span>LOGIN</span><span>(</span><span>0</span><span>)</span><span>;</span>\n    <span>LOGIN</span><span>(</span><span>0</span><span>)</span><span>;</span>\n    <span>// 会导致代码体积增大</span>\n\n    <span>show</span><span>(</span><span>)</span><span>;</span>\n    <span>show</span><span>(</span><span>)</span><span>;</span>\n    <span>show</span><span>(</span><span>)</span><span>;</span>\n    <span>show</span><span>(</span><span>)</span><span>;</span>\n    <span>show</span><span>(</span><span>)</span><span>;</span>\n    <span>// 普通函数，每次都会进栈 弹栈 ，不会导致代码体积增大</span>\n\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n\n<span>// 宏函数</span>\n<span>/*\n * 优点：\n *   1.文本替换，不会造成函数的调用开销(开辟栈空间，形参压栈，函数弹栈释放 ..)\n *\n * 缺点：\n *   1.会导致代码体积增大\n *\n */</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"c-异常\" tabindex=\"-1\"> C++异常</h3>\n<ul>\n<li>c++异常必须是根据类型来抛出异常</li>\n</ul>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n<span><span>#</span><span>include</span> <span>&lt;string></span></span>\n<span>using</span> <span>namespace</span> std<span>;</span>\n\n<span>void</span> <span>exceptionMethod01</span><span>(</span><span>)</span> <span>{</span>\n    <span>throw</span> <span>\"我报废了\"</span><span>;</span> <span>// const char *</span>\n<span>}</span>\n\n<span>class</span> <span>Student</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>char</span> <span>*</span> <span>getInfo</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"自定义\"</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n\n<span>void</span> <span>exceptionMethod02</span><span>(</span><span>)</span> <span>{</span>\n    Student student<span>;</span>\n    <span>throw</span> student<span>;</span>\n<span>}</span>\n\n<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    <span>try</span> <span>{</span>\n        <span>exceptionMethod01</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span> <span>const</span> <span>char</span> <span>*</span> <span>&amp;</span> msg<span>)</span> <span>{</span>\n        cout <span>&lt;&lt;</span> <span>\"捕获到异常1：\"</span> <span>&lt;&lt;</span> msg <span>&lt;&lt;</span> endl<span>;</span>\n    <span>}</span>\n\n    <span>try</span> <span>{</span>\n        <span>exceptionMethod02</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span>Student <span>&amp;</span> msg<span>)</span> <span>{</span>\n        cout <span>&lt;&lt;</span> <span>\"捕获到异常2：\"</span> <span>&lt;&lt;</span> msg<span>.</span><span>getInfo</span><span>(</span><span>)</span> <span>&lt;&lt;</span> endl<span>;</span>\n    <span>}</span>\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>",
      "date_published": "2022-09-19T03:10:30.000Z",
      "date_modified": "2022-09-19T03:10:30.000Z",
      "authors": [],
      "tags": [
        "NDK"
      ]
    },
    {
      "title": "Jni之分析Parcel源码",
      "url": "https://yangzhanlong.github.io/android/ndk/Jni-Parcel.html",
      "id": "https://yangzhanlong.github.io/android/ndk/Jni-Parcel.html",
      "content_html": "<h1 id=\"jni之分析parcel源码\" tabindex=\"-1\"> Jni之分析Parcel源码</h1>\n",
      "date_published": "2022-09-19T03:10:30.000Z",
      "date_modified": "2022-09-19T03:10:30.000Z",
      "authors": [],
      "tags": [
        "NDK"
      ]
    },
    {
      "title": "Jni基础",
      "url": "https://yangzhanlong.github.io/android/ndk/Jni-base.html",
      "id": "https://yangzhanlong.github.io/android/ndk/Jni-base.html",
      "content_html": "<h1 id=\"jni基础\" tabindex=\"-1\"> Jni基础</h1>\n<h3 id=\"jni概述\" tabindex=\"-1\"> JNI概述</h3>\n<ul>\n<li>定义：<code>Java Native Interface</code> ，即Java本地接口</li>\n<li>作用：使得Java与本地其他语言(c,c++)交互</li>\n<li>JNI是属于Java的，与Android没有关系</li>\n<li>实际中的驱动都是c,c开放的，通过JNI.Java可以调用c/c实现的驱动，从而扩展java虚拟机的能力</li>\n</ul>\n<h3 id=\"为什么要有jni\" tabindex=\"-1\"> 为什么要有JNI</h3>\n<ul>\n<li>Java需要与本地代码进行交互，因为java具备跨平台的特点，所以java与本地代码交互的能力非常弱，采用jni特效增强java与本地代码交互的能力</li>\n</ul>\n<h3 id=\"jni与ndk的关系\" tabindex=\"-1\"> JNI与NDK的关系</h3>\n<ul>\n<li>jni属于java jvm虚拟机的技术，ndk是工具集,是属于Android，NDK集成了jni,c++,gcc 等各种工具</li>\n</ul>\n<h3 id=\"第一个ndk项目\" tabindex=\"-1\"> 第一个NDK项目</h3>\n<ol>\n<li>选择Native C++新建项目</li>\n<li>创建完成后，会在main目录下有一个cpp的目录，里面包含<code>CMakeLists.txt</code>和<code>native-lib.cpp</code></li>\n</ol>\n<h4 id=\"头文件解释\" tabindex=\"-1\"> 头文件解释</h4>\n<ol>\n<li>使用<code>javah</code> 命令生成头文件</li>\n</ol>\n<div><pre><code>javah <span>-classpath</span> <span>.</span> <span>-jni</span> <span>-d</span> /Users/yang/Study/Ndk/Jni/JniStudy/app/src/main/java com.multi.jnistudy.TestActivity\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><ol start=\"2\">\n<li>得到的头文件 <code>com_multi_jnistudy_TestActivity.h</code></li>\n</ol>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;jni.h></span></span>\n\n<span>// 解决循环依赖的问题，第二次进不来</span>\n<span><span>#</span><span>ifndef</span> <span>_Included_com_multi_jnistudy_TestActivity </span><span>// 如果没有这个宏</span></span>\n<span><span>#</span><span>define</span> <span>_Included_com_multi_jnistudy_TestActivity</span> <span>// 就定义这个宏</span></span>\n<span><span>#</span><span>ifdef</span> <span>__cplusplus </span><span>// 如果是c++环境</span></span>\n<span>extern</span> <span>\"C\"</span> <span>{</span> <span>// 全部采用c的方式,不允许你函数重载，函数名一样的问题</span>\n    <span><span>#</span><span>endif</span></span>\n    <span><span>#</span><span>undef</span> <span>com_multi_jnistudy_TestActivity_A</span></span>\n    <span><span>#</span><span>define</span> <span>com_multi_jnistudy_TestActivity_A</span> <span><span>100L</span></span></span>\n    <span>/*\n    * 函数的声明\n    * Class:     com_multi_jnistudy_TestActivity\n    * Method:    getStringPwd\n    * Signature: ()Ljava/lang/String;\n    */</span>\n    JNIEXPORT jstring JNICALL <span>Java_com_multi_jnistudy_TestActivity_getStringPwd</span>\n        <span>(</span>JNIEnv <span>*</span><span>,</span> jobject<span>)</span><span>;</span>\n    \n    <span>/*\n    * Class:     com_multi_jnistudy_TestActivity\n    * Method:    getStringPwd2\n    * Signature: ()Ljava/lang/String;\n    */</span>\n    JNIEXPORT jstring JNICALL <span>Java_com_multi_jnistudy_TestActivity_getStringPwd2</span>\n        <span>(</span>JNIEnv <span>*</span><span>,</span> jclass<span>)</span><span>;</span>\n    \n    <span><span>#</span><span>ifdef</span> <span>__cplusplus</span></span>\n<span>}</span>\n<span><span>#</span><span>endif</span></span>\n<span><span>#</span><span>endif</span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id=\"cpp文件解释\" tabindex=\"-1\"> cpp文件解释</h4>\n<ol>\n<li>extern &quot;C&quot;</li>\n</ol>\n<blockquote>\n<p>extern &quot;C&quot;： 必须采用C的编译方式，为什么，请看JNIEnv内部源码\n无论是C还是C++ 最终是调用到 C的JNINativeInterface，所以必须采用C的方式 extern &quot;C&quot; 函数的实现</p>\n</blockquote>\n<ol start=\"2\">\n<li>JNIEXPORT</li>\n</ol>\n<blockquote>\n<p>标记该方法可以被外部调用（VS上不加入 运行会报错， AS上不加入运行没有问题）\nLinux运行不加入，不报错, Win 你必须加入 否则运行报错, MacOS 还不知道</p>\n</blockquote>\n<ol start=\"3\">\n<li>jstring</li>\n</ol>\n<blockquote>\n<p>Java &lt;---&gt; native 转换用的</p>\n</blockquote>\n<ol start=\"4\">\n<li>JNICALL</li>\n</ol>\n<blockquote>\n<p>代表是 JNI标记，可以少</p>\n</blockquote>\n<ol start=\"5\">\n<li>Java_com_multi_jnistudy_MainActivity_getStringPwd</li>\n</ol>\n<blockquote>\n<p>Java_包名_类名_方法名 注意：我们的包名  native_1</p>\n</blockquote>\n<ol start=\"6\">\n<li>JNIEnv*</li>\n</ol>\n<blockquote>\n<p>JNIEnv * env  JNI：的桥梁环境    300多个函数，所以的JNI操作，必须靠他</p>\n</blockquote>\n<ol start=\"7\">\n<li>jobject</li>\n</ol>\n<blockquote>\n<p>jobject jobj  谁调用，就是谁的实例  MainActivity this</p>\n</blockquote>\n<ol start=\"8\">\n<li>jclass</li>\n</ol>\n<blockquote>\n<p>jclass clazz 谁调用，就是谁的class MainActivity.class 静态方法</p>\n</blockquote>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;jni.h></span></span>\n<span><span>#</span><span>include</span> <span>&lt;string></span></span>\n\n<span>// NDK工具链里面的 log 库 引入过来</span>\n<span><span>#</span><span>include</span> <span>&lt;android/log.h></span></span>\n\n<span><span>#</span><span>define</span> <span>TAG</span> <span>\"Yang\"</span></span>\n<span>// ... 我都不知道传入什么  借助JNI里面的宏来自动帮我填充</span>\n<span><span>#</span><span>define</span> <span>LOGD</span><span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span> <span>__android_log_print</span><span>(</span>ANDROID_LOG_DEBUG<span>,</span> TAG<span>,</span> __VA_ARGS__<span>)</span></span></span>\n<span><span>#</span><span>define</span> <span>LOGE</span><span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span> <span>__android_log_print</span><span>(</span>ANDROID_LOG_ERROR<span>,</span> TAG<span>,</span> __VA_ARGS__<span>)</span></span></span>\n<span><span>#</span><span>define</span> <span>LOGI</span><span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span> <span>__android_log_print</span><span>(</span>ANDROID_LOG_INFO<span>,</span> TAG<span>,</span> __VA_ARGS__<span>)</span></span></span>\n\n<span>// extern \"C\"： 必须采用C的编译方式，为什么，请看JNIEnv内部源码</span>\n<span>// 无论是C还是C++ 最终是调用到 C的JNINativeInterface，所以必须采用C的方式 extern \"C\"</span>\n<span>// 函数的实现</span>\n<span>extern</span> <span>\"C\"</span>\n\n<span>//标记该方法可以被外部调用（VS上不加入 运行会报错， AS上不加入运行没有问题）</span>\n<span>//Linux运行不加入，不报错,  Win 你必须加入 否则运行报错,   MacOS 还不知道</span>\nJNIEXPORT\n\n<span>// Java &lt;---> native 转换用的</span>\njstring\n\n<span>// 代表是 JNI标记，可以少</span>\nJNICALL\n\n<span>// Java_包名_类名_方法名  ，注意：我们的包名 _     native _1</span>\n\n<span>// JNIEnv * env  JNI：的桥梁环境    300多个函数，所以的JNI操作，必须靠他</span>\n\n<span>// jobject jobj  谁调用，就是谁的实例  MainActivity this</span>\n<span>// jclass clazz 谁调用，就是谁的class MainActivity.class 静态方法</span>\n<span>Java_com_multi_jnistudy_MainActivity_getStringPwd</span><span>(</span>JNIEnv <span>*</span>env<span>,</span> jobject thiz<span>)</span> <span>{</span>\n\n<span>}</span>\n<span>extern</span> <span>\"C\"</span>\nJNIEXPORT jstring JNICALL\n<span>Java_com_multi_jnistudy_MainActivity_getStringPwd2</span><span>(</span>JNIEnv <span>*</span>env<span>,</span> jobject thiz<span>)</span> <span>{</span>\n\n<span>}</span>\n<span>extern</span> <span>\"C\"</span>\nJNIEXPORT jstring JNICALL\n<span>Java_com_multi_jnistudy_MainActivity_getMyName</span><span>(</span>JNIEnv <span>*</span>env<span>,</span> jclass clazz<span>)</span> <span>{</span>\n\n    <span>/**\n    *  class _jarray : public _jobject {};\n       class _jobjectArray : public _jarray {};\n       typedef _jobjectArray*  jobjectArray;\n       typedef _jarray*        jarray;\n\n       jobjectArray 继承 jarray\n    */</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>// 生成头文件：javah com.multi.jnistudy.MainActivity</span>\n<span>class</span> MainActivity <span>:</span> <span>AppCompatActivity</span><span>(</span><span>)</span> <span>{</span>\n\n    <span>private</span> <span>lateinit</span> <span>var</span> binding<span>:</span> ActivityMainBinding\n    <span>val</span> A <span>=</span> <span>100</span>\n    <span>var</span> name <span>=</span> <span><span>\"Yang\"</span></span> <span>// 签名：Ljava/lang/String;</span>\n    <span>var</span> age <span>=</span> <span>29</span> <span>// 签名：I</span>\n\n\n    <span>override</span> <span>fun</span> <span>onCreate</span><span>(</span>savedInstanceState<span>:</span> Bundle<span>?</span><span>)</span> <span>{</span>\n        <span>super</span><span>.</span><span>onCreate</span><span>(</span>savedInstanceState<span>)</span>\n\n        binding <span>=</span> ActivityMainBinding<span>.</span><span>inflate</span><span>(</span>layoutInflater<span>)</span>\n        <span>setContentView</span><span>(</span>binding<span>.</span>root<span>)</span>\n    <span>}</span>\n\n    <span>// Java 本地方法  实现：native层</span>\n    <span>external</span> <span>fun</span> <span>getStringPwd</span><span>(</span><span>)</span><span>:</span> String\n    <span>external</span> <span>fun</span> <span>getStringPwd2</span><span>(</span><span>)</span><span>:</span> String\n\n\n    <span>companion</span> <span>object</span> <span>{</span>\n        <span>// Used to load the 'jnistudy' library on application startup.</span>\n        <span>init</span> <span>{</span>\n            System<span>.</span><span>loadLibrary</span><span>(</span><span><span>\"jnistudy\"</span></span><span>)</span>\n        <span>}</span>\n\n        <span>@JvmStatic</span>\n        <span>external</span> <span>fun</span> <span>getMyName</span><span>(</span><span>)</span><span>:</span>String <span>// 静态方法</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"签名规则\" tabindex=\"-1\"> 签名规则</h3>\n<ul>\n<li>javap -s -p MainActivity     必须是.class</li>\n<li>javap -s -p xxx.class    -s 输出xxxx.class的所有属性和方法的签名，   -p 忽略私有公开的所有属性方法全部输出</li>\n</ul>\n<div><pre><code>Java的boolean  --- Z  注意点\nJava的byte  --- B\nJava的char  --- C\nJava的short  --- S\nJava的int  --- I\nJava的long  --- J     注意点\nJava的float  --- F\nJava的double  --- D\nJava的void  --- V\nJava的引用类型  --- Lxxx/xxx/xx/类名;\nJava的String  --- Ljava/lang/String;\nJava的array  int[]  --- [I         double[][][][]  --- [[[D\nint add(char c1, char c2) ---- (CC)I\nvoid a()     ===  ()V\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"jni简单例子\" tabindex=\"-1\"> JNI简单例子</h3>\n<div><pre><code><span>class</span> MainActivity <span>:</span> <span>AppCompatActivity</span><span>(</span><span>)</span> <span>{</span>\n\n    <span>private</span> <span>lateinit</span> <span>var</span> binding<span>:</span> ActivityMainBinding\n    <span>var</span> name <span>=</span> <span><span>\"Yang\"</span></span> <span>// 签名：Ljava/lang/String;</span>\n    <span>//var age = 29 // 签名：I</span>\n\n    <span>override</span> <span>fun</span> <span>onCreate</span><span>(</span>savedInstanceState<span>:</span> Bundle<span>?</span><span>)</span> <span>{</span>\n        <span>super</span><span>.</span><span>onCreate</span><span>(</span>savedInstanceState<span>)</span>\n\n        binding <span>=</span> ActivityMainBinding<span>.</span><span>inflate</span><span>(</span>layoutInflater<span>)</span>\n        <span>setContentView</span><span>(</span>binding<span>.</span>root<span>)</span>\n        <span>changeName</span><span>(</span><span>)</span>\n        Log<span>.</span><span>i</span><span>(</span><span><span>\"Yang\"</span></span><span>,</span> <span><span>\"修改后的name:</span><span><span>$</span><span>name</span></span><span>\"</span></span><span>)</span>\n        <span>changeAge</span><span>(</span><span>)</span>\n        Log<span>.</span><span>i</span><span>(</span><span><span>\"Yang\"</span></span><span>,</span> <span><span>\"修改后的age:</span><span><span>$</span><span>age</span></span><span>\"</span></span><span>)</span>\n        <span>callAddMethod</span><span>(</span><span>)</span>\n    <span>}</span>\n\n    <span>external</span> <span>fun</span> <span>changeName</span><span>(</span><span>)</span>\n    <span>external</span> <span>fun</span> <span>callAddMethod</span><span>(</span><span>)</span>\n\n    <span>// 专门写一个函数，给native成调用</span>\n    <span>fun</span> <span>add</span><span>(</span>number1<span>:</span> Int<span>,</span> number2<span>:</span> Int<span>)</span><span>:</span> Int <span>{</span>\n        <span>return</span> number1 <span>+</span> number2 <span>+</span> <span>8</span>\n    <span>}</span>\n\n    <span>companion</span> <span>object</span> <span>{</span>\n        <span>// System.load(); 这种是可以绝对路径的加载动态链接库文件</span>\n        <span>// System.loadLibrary 这种是从库目录遍历层级目录，去自动的寻找</span>\n        <span>init</span> <span>{</span>\n            System<span>.</span><span>loadLibrary</span><span>(</span><span><span>\"jnistudy\"</span></span><span>)</span>\n        <span>}</span>\n\n        <span>@JvmStatic</span>\n        <span>external</span> <span>fun</span> <span>changeAge</span><span>(</span><span>)</span>\n        <span>val</span> age <span>=</span> <span>29</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>extern</span> <span>\"C\"</span>\nJNIEXPORT <span>void</span> JNICALL\n<span>Java_com_multi_jnistudy_MainActivity_changeName</span><span>(</span>JNIEnv <span>*</span>env<span>,</span> jobject thiz<span>)</span> <span>{</span>\n    <span>// 获取class</span>\n    jclass j_cls <span>=</span> env<span>-></span><span>GetObjectClass</span><span>(</span>thiz<span>)</span><span>;</span>\n\n    <span>// 获取属性 L对象类型 都需要L</span>\n    <span>// jfieldID GetFieldID(MainActivity.class, 属性名, 属性的签名)</span>\n    jfieldID j_fid <span>=</span> env<span>-></span><span>GetFieldID</span><span>(</span>j_cls<span>,</span> <span>\"name\"</span><span>,</span> <span>\"Ljava/lang/String;\"</span><span>)</span><span>;</span>\n    <span>// 从class获取jfieldID的属性值 static_cast:强转</span>\n    jstring j_str <span>=</span> <span><span>static_cast</span><span><span>&lt;</span>jstring<span>></span></span></span><span>(</span>env<span>-></span><span>GetObjectField</span><span>(</span>thiz<span>,</span> j_fid<span>)</span><span>)</span><span>;</span>\n    <span>// jni字符串转成c++字符串</span>\n    <span>char</span> <span>*</span> c_str <span>=</span> <span><span>const_cast</span><span><span>&lt;</span><span>char</span> <span>*</span><span>></span></span></span><span>(</span>env<span>-></span><span>GetStringUTFChars</span><span>(</span>j_str<span>,</span> <span>NULL</span><span>)</span><span>)</span><span>;</span>\n    <span>LOGD</span><span>(</span><span>\"native: %s\\n\"</span><span>,</span> c_str<span>)</span><span>;</span>\n\n    jstring name <span>=</span> env<span>-></span><span>NewStringUTF</span><span>(</span><span>\"Yangmi\"</span><span>)</span><span>;</span>\n    <span>//void SetObjectField(jobject obj, jfieldID fieldID, jobject value)</span>\n    env<span>-></span><span>SetObjectField</span><span>(</span>thiz<span>,</span> j_fid<span>,</span> name<span>)</span><span>;</span>\n<span>}</span>\n\n<span>extern</span> <span>\"C\"</span>\nJNIEXPORT <span>void</span> JNICALL\n<span>Java_com_multi_jnistudy_MainActivity_changeAge</span><span>(</span>JNIEnv <span>*</span>env<span>,</span> jclass clazz<span>)</span> <span>{</span>\n    <span>// 修改静态值</span>\n\n    <span>const</span> <span>char</span> <span>*</span> sig <span>=</span> <span>\"I\"</span><span>;</span>\n    <span>//  jfieldID GetStaticFieldID(jclass clazz, const char* name, const char* sig)</span>\n    jfieldID  j_fid <span>=</span> env<span>-></span><span>GetStaticFieldID</span><span>(</span>clazz<span>,</span> <span>\"age\"</span><span>,</span> sig<span>)</span><span>;</span>\n    <span>// jint GetStaticIntField(jclass clazz, jfieldID fieldID)</span>\n    jint age <span>=</span> env<span>-></span><span>GetStaticIntField</span><span>(</span>clazz<span>,</span> j_fid<span>)</span><span>;</span>\n    <span>LOGD</span><span>(</span><span>\"native: %d\\n\"</span><span>,</span> age<span>)</span><span>;</span>\n    age<span>+=</span><span>10</span><span>;</span>\n    env<span>-></span><span>SetStaticIntField</span><span>(</span>clazz<span>,</span> j_fid<span>,</span> age<span>)</span><span>;</span>\n<span>}</span>\n\n<span>extern</span> <span>\"C\"</span>\nJNIEXPORT <span>void</span> JNICALL\n<span>Java_com_multi_jnistudy_MainActivity_callAddMethod</span><span>(</span>JNIEnv <span>*</span>env<span>,</span> jobject thiz<span>)</span> <span>{</span>\n    <span>// 自己得到 MainActivity.class</span>\n    jclass  mainActivityClass <span>=</span> env<span>-></span><span>GetObjectClass</span><span>(</span>thiz<span>)</span><span>;</span>\n\n    <span>// GetMethodID(MainActivity.class, 方法名, 方法的签名)</span>\n    jmethodID j_mid <span>=</span> env<span>-></span><span>GetMethodID</span><span>(</span>mainActivityClass<span>,</span> <span>\"add\"</span><span>,</span> <span>\"(II)I\"</span><span>)</span><span>;</span>\n\n    <span>// 调用 Java的方法</span>\n    jint sum <span>=</span> env<span>-></span><span>CallIntMethod</span><span>(</span>thiz<span>,</span> j_mid<span>,</span> <span>3</span><span>,</span> <span>3</span><span>)</span><span>;</span>\n    <span>LOGE</span><span>(</span><span>\"sum result:%d\"</span><span>,</span> sum<span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"jni操作\" tabindex=\"-1\"> JNI操作</h3>\n<div><pre><code><span>class</span> MainActivity <span>:</span> <span>AppCompatActivity</span><span>(</span><span>)</span> <span>{</span>\n\n     <span>private</span> <span>val</span> TAG <span>=</span> MainActivity<span>::</span><span>class</span><span>.</span>java<span>.</span>simpleName\n\n    static <span>{</span>\n        <span>// System.load(); 这种是可以绝对路径的加载动态链接库文件</span>\n        System<span>.</span><span>loadLibrary</span><span>(</span><span><span>\"native-lib\"</span></span><span>)</span><span>;</span> <span>// 这种是从库目录遍历层级目录，去自动的寻找</span>\n    <span>}</span>\n\n    <span>override</span> <span>fun</span> <span>onCreate</span><span>(</span>savedInstanceState<span>:</span> Bundle<span>?</span><span>)</span> <span>{</span>\n        <span>super</span><span>.</span><span>onCreate</span><span>(</span>savedInstanceState<span>)</span>\n        binding <span>=</span> ActivityMainBinding<span>.</span><span>inflate</span><span>(</span>layoutInflater<span>)</span>\n        <span>setContentView</span><span>(</span>binding<span>.</span>root<span>)</span>\n    <span>}</span>\n\n    <span>/**\n     * 下面是 native 区域\n     */</span>\n\n    <span>external</span> <span>fun</span> <span>testArrayAction</span><span>(</span>\n        count<span>:</span> Int<span>,</span>\n        textInfo<span>:</span> String<span>,</span>\n        ints<span>:</span> IntArray<span>,</span>\n        strs<span>:</span> Array<span>&lt;</span>String<span>></span>\n    <span>)</span> <span>// String引用类型，玩数组</span>\n\n\n    <span>external</span> <span>fun</span> <span>putObject</span><span>(</span>student<span>:</span> Student<span>,</span> str<span>:</span> String<span>)</span> <span>// 传递引用类型，传递对象</span>\n\n\n    <span>external</span> <span>fun</span> <span>insertObject</span><span>(</span><span>)</span> <span>// 凭空创建Java对象</span>\n\n\n    <span>external</span> <span>fun</span> <span>testQuote</span><span>(</span><span>)</span> <span>// 测试引用</span>\n\n    <span>external</span> <span>fun</span> <span>delQuote</span><span>(</span><span>)</span> <span>// 释放全局引用</span>\n\n    <span>external</span> <span>fun</span> <span>textExternal</span><span>(</span><span>)</span>\n\n\n    <span>/**\n     * 下面是 点击事件区域\n     */</span>\n     <span>// 点击事件：操作testArrayAction函数</span>\n     <span>fun</span> <span>test01</span><span>(</span>view<span>:</span> View<span>)</span> <span>{</span>\n        <span>val</span> ints <span>=</span> <span>intArrayOf</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>)</span>\n        <span>val</span> strs <span>=</span> <span>arrayOf</span><span>(</span><span><span>\"李小龙\"</span></span><span>,</span> <span><span>\"李连杰\"</span></span><span>,</span> <span><span>\"李元霸\"</span></span><span>)</span>\n        <span>testArrayAction</span><span>(</span><span>99</span><span>,</span> <span><span>\"你好\"</span></span><span>,</span> ints<span>,</span> strs<span>)</span><span>;</span>\n\n        <span>for</span> <span>(</span>anInt <span>in</span> ints<span>)</span> <span>{</span>\n            Log<span>.</span><span>d</span><span>(</span>TAG<span>,</span> <span><span>\"test01: anInt:</span><span><span>$</span><span>anInt</span></span><span>\"</span></span><span>)</span>\n        <span>}</span>\n    <span>}</span>\n    \n    <span>// 点击事件：操作putObject函数 </span>\n    <span>fun</span> <span>test02</span><span>(</span>view<span>:</span> View<span>)</span> <span>{</span>\n        <span>val</span> student <span>=</span> <span>Student</span><span>(</span><span>)</span>\n        student<span>.</span>name <span>=</span> <span><span>\"史泰龙\"</span></span>\n        student<span>.</span>age <span>=</span> <span>88</span>\n        <span>putObject</span><span>(</span>student<span>,</span> <span><span>\"九阳神功\"</span></span><span>)</span>\n    <span>}</span>\n    \n    <span>// 点击事件：操作insertObject函数</span>\n    <span>fun</span> <span>test03</span><span>(</span>view<span>:</span> View<span>)</span> <span>{</span>\n        <span>insertObject</span><span>(</span><span>)</span>\n    <span>}</span>\n    \n    <span>// 点击事件：两个函数是一起的，操作引用 与 释放引用</span>\n    <span>fun</span> <span>test04</span><span>(</span>view<span>:</span> View<span>)</span> <span>{</span>\n        <span>testQuote</span><span>(</span><span>)</span>\n    <span>}</span>\n    <span>fun</span> <span>test05</span><span>(</span>view<span>:</span> View<span>)</span> <span>{</span>\n        <span>delQuote</span><span>(</span><span>)</span>\n    <span>}</span>\n\n    <span>fun</span> <span>test06</span><span>(</span>view<span>:</span> View<span>)</span> <span>{</span>\n        <span>textExternal</span><span>(</span><span>)</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id=\"数组操作\" tabindex=\"-1\"> 数组操作</h4>\n<p><code>GetIntArrayElements</code> <code>GetArrayLength</code> <code>GetObjectArrayElement</code></p>\n<div><pre><code><span>/**\n *  jint == int\n    jstring == String\n    jintArray == int[]\n    jobjectArray == 引用类型对象，例如 String[]   Test[]   Student[]  Person[]\n */</span>\n<span>extern</span> <span>\"C\"</span>\nJNIEXPORT <span>void</span> JNICALL\n<span>Java_com_multi_jnistudy_MainActivity_testArrayAction</span><span>(</span>JNIEnv <span>*</span>env<span>,</span> jobject thiz<span>,</span> jint count<span>,</span>\n                                                     jstring text_info<span>,</span> jintArray ints<span>,</span>\n                                                     jobjectArray strs<span>)</span> <span>{</span>\n    <span>// ① 基本数据类型  jint count， jstring text_info， 最简单的</span>\n    <span>int</span> countInt <span>=</span> count<span>;</span>\n    <span>LOGI</span><span>(</span><span>\"参数1：%d\\n\"</span><span>,</span> countInt<span>)</span><span>;</span>\n\n    <span>// const char* GetStringUTFChars(jstring string, jboolean* isCopy)</span>\n    <span>const</span> <span>char</span> <span>*</span> textInfo <span>=</span> env<span>-></span><span>GetStringUTFChars</span><span>(</span>text_info<span>,</span> <span>NULL</span><span>)</span><span>;</span>\n    <span>LOGI</span><span>(</span><span>\"参数二 textInfo:%s\\n\"</span><span>,</span> textInfo<span>)</span><span>;</span>\n\n    <span>// ② 把int[] 转成 int*</span>\n    <span>// jint* GetIntArrayElements(jintArray array, jboolean* isCopy)</span>\n    <span>int</span><span>*</span> jintArray <span>=</span> env<span>-></span><span>GetIntArrayElements</span><span>(</span>ints<span>,</span> <span>NULL</span><span>)</span><span>;</span>\n    <span>// Java层数组的长度</span>\n    <span>// 目前无法控制Java的数组 变化 +100</span>\n    <span>// jsize GetArrayLength(jarray array) // jintArray ints 可以放入到 jarray的参数中去</span>\n    jsize size <span>=</span> env<span>-></span><span>GetArrayLength</span><span>(</span>ints<span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> <span>++</span>i<span>)</span> <span>{</span>\n        <span>*</span><span>(</span>jintArray<span>+</span>i<span>)</span> <span>+=</span> <span>100</span><span>;</span> <span>// C++的修改，影响不了Java层</span>\n        <span>LOGI</span><span>(</span><span>\"参数三 int[]:%d\\n\"</span><span>,</span> <span>*</span>jintArray<span>+</span>i<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 0:           刷新Java数组，并 释放C++层数组\n     * JNI_COMMIT:  只提交 只刷新Java数组，不释放C++层数组\n     * JNI_ABORT:   只释放C++层数组\n     */</span>\n    env<span>-></span><span>ReleaseIntArrayElements</span><span>(</span>ints<span>,</span> jintArray<span>,</span> <span>0</span><span>)</span><span>;</span>\n\n    <span>// ③：jobjectArray 代表是Java的引用类型数组，不一样</span>\n    jsize  strssize <span>=</span> env<span>-></span><span>GetArrayLength</span><span>(</span>strs<span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> strssize<span>;</span> <span>++</span>i<span>)</span> <span>{</span>\n\n        jstring jobj <span>=</span> <span><span>static_cast</span><span><span>&lt;</span>jstring<span>></span></span></span><span>(</span>env<span>-></span><span>GetObjectArrayElement</span><span>(</span>strs<span>,</span> i<span>)</span><span>)</span><span>;</span>\n\n        <span>// 模糊：isCopy内部启动的机制</span>\n        <span>// const char* GetStringUTFChars(jstring string, jboolean* isCopy)</span>\n        <span>const</span> <span>char</span> <span>*</span> jobjCharp <span>=</span> env<span>-></span><span>GetStringUTFChars</span><span>(</span>jobj<span>,</span> <span>NULL</span><span>)</span><span>;</span>\n\n        <span>LOGI</span><span>(</span><span>\"参数四 引用类型String 具体的：%s\\n\"</span><span>,</span> jobjCharp<span>)</span><span>;</span>\n\n        <span>// 释放jstring</span>\n        env<span>-></span><span>ReleaseStringUTFChars</span><span>(</span>jobj<span>,</span> jobjCharp<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id=\"对象操作\" tabindex=\"-1\"> 对象操作</h4>\n<div><pre><code><span>// jobject student == Student</span>\n<span>// jstring str  == String</span>\n<span>extern</span> <span>\"C\"</span>\nJNIEXPORT <span>void</span> JNICALL\n<span>Java_com_derry_as_1jni_1project_MainActivity_putObject</span><span>(</span>JNIEnv <span>*</span>env<span>,</span>\n                                                       jobject thiz<span>,</span>\n                                                       jobject student<span>,</span>\n                                                       jstring str<span>)</span> <span>{</span>\n    <span>const</span> <span>char</span> <span>*</span> strChar <span>=</span> env<span>-></span><span>GetStringUTFChars</span><span>(</span>str<span>,</span> <span>NULL</span><span>)</span><span>;</span>\n    <span>LOGI</span><span>(</span><span>\"strChar：%s\\n\"</span><span>,</span> strChar<span>)</span><span>;</span>\n    env<span>-></span><span>ReleaseStringUTFChars</span><span>(</span>str<span>,</span> strChar<span>)</span><span>;</span>\n\n    <span>// --------------</span>\n    <span>// 1.寻找类 Student</span>\n    <span>// jclass studentClass = env->FindClass(\"com/derry/as_jni_project/Student\"); // 第一种</span>\n    jclass studentClass <span>=</span>  env<span>-></span><span>GetObjectClass</span><span>(</span>student<span>)</span><span>;</span> <span>// 第二种</span>\n\n    <span>// 2.Student类里面的函数规则  签名</span>\n    jmethodID setName <span>=</span> env<span>-></span><span>GetMethodID</span><span>(</span>studentClass<span>,</span> <span>\"setName\"</span><span>,</span> <span>\"(Ljava/lang/String;)V\"</span><span>)</span><span>;</span>\n    jmethodID getName <span>=</span> env<span>-></span><span>GetMethodID</span><span>(</span>studentClass<span>,</span> <span>\"getName\"</span><span>,</span> <span>\"()Ljava/lang/String;\"</span><span>)</span><span>;</span>\n    jmethodID showInfo <span>=</span> env<span>-></span><span>GetStaticMethodID</span><span>(</span>studentClass<span>,</span> <span>\"showInfo\"</span><span>,</span> <span>\"(Ljava/lang/String;)V\"</span><span>)</span><span>;</span>\n\n    <span>// 3.调用 setName</span>\n    jstring value <span>=</span> env<span>-></span><span>NewStringUTF</span><span>(</span><span>\"AAAA\"</span><span>)</span><span>;</span>\n    env<span>-></span><span>CallVoidMethod</span><span>(</span>student<span>,</span> setName<span>,</span> value<span>)</span><span>;</span>\n\n    <span>// 4.调用 getName</span>\n    jstring getNameResult <span>=</span> <span><span>static_cast</span><span><span>&lt;</span>jstring<span>></span></span></span><span>(</span>env<span>-></span><span>CallObjectMethod</span><span>(</span>student<span>,</span> getName<span>)</span><span>)</span><span>;</span>\n    <span>const</span> <span>char</span> <span>*</span> getNameValue <span>=</span> env<span>-></span><span>GetStringUTFChars</span><span>(</span>getNameResult<span>,</span> <span>NULL</span><span>)</span><span>;</span>\n    <span>LOGE</span><span>(</span><span>\"调用到getName方法，值是:%s\\n\"</span><span>,</span> getNameValue<span>)</span><span>;</span>\n\n    <span>// 5.调用静态showInfo</span>\n    jstring  jstringValue <span>=</span> env<span>-></span><span>NewStringUTF</span><span>(</span><span>\"静态方法你好，我是C++\"</span><span>)</span><span>;</span>\n    env<span>-></span><span>CallStaticVoidMethod</span><span>(</span>studentClass<span>,</span> showInfo<span>,</span> jstringValue<span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id=\"对象操作进阶\" tabindex=\"-1\"> 对象操作进阶</h4>\n<div><pre><code><span>extern</span> <span>\"C\"</span>\nJNIEXPORT <span>void</span> JNICALL\n<span>Java_com_derry_as_1jni_1project_MainActivity_insertObject</span><span>(</span>JNIEnv <span>*</span>env<span>,</span> jobject thiz<span>)</span> <span>{</span>\n    <span>// 1.通过包名+类名的方式 拿到 Student class  凭空拿class</span>\n    <span>const</span> <span>char</span> <span>*</span>studentstr <span>=</span> <span>\"com/derry/as_jni_project/Student\"</span><span>;</span>\n    jclass studentClass <span>=</span> env<span>-></span><span>FindClass</span><span>(</span>studentstr<span>)</span><span>;</span>\n\n    <span>// 2.通过student的class  实例化此Student对象   C++ new Student</span>\n    jobject studentObj <span>=</span> env<span>-></span><span>AllocObject</span><span>(</span>studentClass<span>)</span><span>;</span> <span>// AllocObject 只实例化对象，不会调用对象的构造函数</span>\n\n    <span>// 方法签名的规则</span>\n    jmethodID setName <span>=</span> env<span>-></span><span>GetMethodID</span><span>(</span>studentClass<span>,</span> <span>\"setName\"</span><span>,</span> <span>\"(Ljava/lang/String;)V\"</span><span>)</span><span>;</span>\n    jmethodID setAge <span>=</span> env<span>-></span><span>GetMethodID</span><span>(</span>studentClass<span>,</span> <span>\"setAge\"</span><span>,</span> <span>\"(I)V\"</span><span>)</span><span>;</span>\n\n    <span>// 调用方法</span>\n    jstring strValue <span>=</span> env<span>-></span><span>NewStringUTF</span><span>(</span><span>\"Derry\"</span><span>)</span><span>;</span>\n    env<span>-></span><span>CallVoidMethod</span><span>(</span>studentObj<span>,</span> setName<span>,</span> strValue<span>)</span><span>;</span>\n    env<span>-></span><span>CallVoidMethod</span><span>(</span>studentObj<span>,</span> setAge<span>,</span> <span>99</span><span>)</span><span>;</span>\n\n\n    <span>// env->NewObject() // NewObject 实例化对象，会调用对象的构造函数</span>\n\n\n    <span>// ====================  下面是 Person对象  调用person对象的  setStudent 函数等</span>\n\n    <span>// 4.通过包名+类名的方式 拿到 Student class  凭空拿class</span>\n    <span>const</span> <span>char</span> <span>*</span>personstr <span>=</span> <span>\"com/derry/as_jni_project/Person\"</span><span>;</span>\n    jclass personClass <span>=</span> env<span>-></span><span>FindClass</span><span>(</span>personstr<span>)</span><span>;</span>\n\n    jobject personObj <span>=</span> env<span>-></span><span>AllocObject</span><span>(</span>personClass<span>)</span><span>;</span> <span>// AllocObject 只实例化对象，不会调用对象的构造函数</span>\n\n    <span>// setStudent 此函数的 签名 规则</span>\n    jmethodID setStudent <span>=</span> env<span>-></span><span>GetMethodID</span><span>(</span>personClass<span>,</span> <span>\"setStudent\"</span><span>,</span>\n            <span>\"(Lcom/derry/as_jni_project/Student;)V\"</span><span>)</span><span>;</span>\n\n    env<span>-></span><span>CallVoidMethod</span><span>(</span>personObj<span>,</span> setStudent<span>,</span> studentObj<span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id=\"全局引用-局部引用理解\" tabindex=\"-1\"> 全局引用 局部引用理解</h4>\n<div><pre><code>jclass dogClass<span>;</span> <span>// 你以为这个是全局引用，实际上他还是局部引用</span>\n\n<span>extern</span> <span>\"C\"</span>\nJNIEXPORT <span>void</span> JNICALL\n<span>Java_com_derry_as_1jni_1project_MainActivity_testQuote</span><span>(</span>JNIEnv <span>*</span>env<span>,</span> jobject thiz<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>NULL</span> <span>==</span> dogClass<span>)</span> <span>{</span>\n        <span>/*const char * dogStr = \"com/derry/as_jni_project/Dog\";\n        dogClass = env->FindClass(dogStr);*/</span>\n\n        <span>// 升级全局引用： JNI函数结束也不释放，反正就是不释放，必须手动释放   ----- 相当于： C++ 对象 new、手动delete</span>\n        <span>const</span> <span>char</span> <span>*</span> dogStr <span>=</span> <span>\"com/derry/as_jni_project/Dog\"</span><span>;</span>\n        jclass temp <span>=</span> env<span>-></span><span>FindClass</span><span>(</span>dogStr<span>)</span><span>;</span>\n        dogClass <span>=</span> <span><span>static_cast</span><span><span>&lt;</span>jclass<span>></span></span></span><span>(</span>env<span>-></span><span>NewGlobalRef</span><span>(</span>temp<span>)</span><span>)</span><span>;</span> <span>// 提升全局引用</span>\n        <span>// 记住：用完了，如果不用了，马上释放，C C++ 工程师的赞美</span>\n        env<span>-></span><span>DeleteLocalRef</span><span>(</span>temp<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// &lt;init> V  是不会变的</span>\n\n    <span>// 构造函数一</span>\n    jmethodID init <span>=</span> env<span>-></span><span>GetMethodID</span><span>(</span>dogClass<span>,</span> <span>\"&lt;init>\"</span><span>,</span> <span>\"()V\"</span><span>)</span><span>;</span>\n    jobject dog <span>=</span> env<span>-></span><span>NewObject</span><span>(</span>dogClass<span>,</span> init<span>)</span><span>;</span>\n\n    <span>// 构造函数2</span>\n    init <span>=</span> env<span>-></span><span>GetMethodID</span><span>(</span>dogClass<span>,</span> <span>\"&lt;init>\"</span><span>,</span> <span>\"(I)V\"</span><span>)</span><span>;</span>\n    dog <span>=</span> env<span>-></span><span>NewObject</span><span>(</span>dogClass<span>,</span> init<span>,</span> <span>100</span><span>)</span><span>;</span>\n\n\n    <span>// 构造函数3</span>\n    init <span>=</span> env<span>-></span><span>GetMethodID</span><span>(</span>dogClass<span>,</span> <span>\"&lt;init>\"</span><span>,</span> <span>\"(II)V\"</span><span>)</span><span>;</span>\n    dog <span>=</span> env<span>-></span><span>NewObject</span><span>(</span>dogClass<span>,</span> init<span>,</span> <span>200</span><span>,</span> <span>300</span><span>)</span><span>;</span>\n\n    <span>// 构造函数4</span>\n    init <span>=</span> env<span>-></span><span>GetMethodID</span><span>(</span>dogClass<span>,</span> <span>\"&lt;init>\"</span><span>,</span> <span>\"(III)V\"</span><span>)</span><span>;</span>\n    dog <span>=</span> env<span>-></span><span>NewObject</span><span>(</span>dogClass<span>,</span> init<span>,</span> <span>400</span><span>,</span> <span>500</span><span>,</span> <span>600</span><span>)</span><span>;</span>\n\n    env<span>-></span><span>DeleteLocalRef</span><span>(</span>dog<span>)</span><span>;</span> <span>// 释放</span>\n<span>}</span>\n\n<span>// JNI函数结束，会释放局部引用   dogClass虽然被释放，但是还不等于NULL，只是一个悬空指针而已，所以第二次进不来IF，会奔溃</span>\n\n<span>// 手动释放全局引用</span>\n<span>extern</span> <span>\"C\"</span>\nJNIEXPORT <span>void</span> JNICALL\n<span>Java_com_derry_as_1jni_1project_MainActivity_delQuote</span><span>(</span>JNIEnv <span>*</span>env<span>,</span> jobject thiz<span>)</span> <span>{</span>\n   <span>if</span> <span>(</span>dogClass <span>!=</span> <span>NULL</span><span>)</span> <span>{</span>\n       <span>LOGE</span><span>(</span><span>\"全局引用释放完毕，上面的按钮已经失去全局引用，再次点击会报错\"</span><span>)</span><span>;</span>\n       env<span>-></span><span>DeleteGlobalRef</span><span>(</span>dogClass<span>)</span><span>;</span>\n       dogClass <span>=</span> <span>NULL</span><span>;</span> <span>// 最好给一个NULL，指向NULL的地址，不要去成为悬空指针</span>\n   <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id=\"extern\" tabindex=\"-1\"> extern</h4>\n<div><pre><code><span><span>#</span><span>include</span> <span>&lt;iostream></span></span>\n\n<span>// 日志输出</span>\n<span><span>#</span><span>include</span> <span>&lt;android/log.h></span></span>\n\n<span><span>#</span><span>define</span> <span>TAG</span> <span>\"JNISTUDY\"</span></span>\n<span>// __VA_ARGS__ 代表 ...的可变参数</span>\n<span><span>#</span><span>define</span> <span>LOGD</span><span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span> <span>__android_log_print</span><span>(</span>ANDROID_LOG_DEBUG<span>,</span> TAG<span>,</span>  __VA_ARGS__<span>)</span><span>;</span></span></span>\n<span><span>#</span><span>define</span> <span>LOGE</span><span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span> <span>__android_log_print</span><span>(</span>ANDROID_LOG_ERROR<span>,</span> TAG<span>,</span>  __VA_ARGS__<span>)</span><span>;</span></span></span>\n<span><span>#</span><span>define</span> <span>LOGI</span><span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span> <span>__android_log_print</span><span>(</span>ANDROID_LOG_INFO<span>,</span> TAG<span>,</span>  __VA_ARGS__<span>)</span><span>;</span></span></span>\n\n<span>int</span> age <span>=</span> <span>99</span><span>;</span> <span>// 实现</span>\n\n<span>void</span> <span>show</span><span>(</span><span>)</span> <span>{</span> <span>// 实现</span>\n    <span>// 5000行代码</span>\n    <span>// ...</span>\n\n    <span>LOGI</span><span>(</span><span>\"show run age:%d\\n\"</span><span>,</span> age<span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>// 非常方便，可以使用了</span>\n<span>extern</span> <span>int</span> age<span>;</span> <span>// 声明age</span>\n<span>extern</span> <span>void</span> <span>show</span><span>(</span><span>)</span><span>;</span> <span>// 声明show函数</span>\n\n<span>extern</span> <span>\"C\"</span>\nJNIEXPORT <span>void</span> JNICALL\n<span>Java_com_multi_jnistudy_MainActivity_textExternal</span><span>(</span>JNIEnv <span>*</span>env<span>,</span> jobject thiz<span>)</span> <span>{</span>\n    <span>show</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>",
      "date_published": "2022-09-19T03:10:30.000Z",
      "date_modified": "2022-09-19T03:10:30.000Z",
      "authors": [],
      "tags": [
        "NDK"
      ]
    },
    {
      "title": "Jni导入c库开放流程",
      "url": "https://yangzhanlong.github.io/android/ndk/Jni-c-dev.html",
      "id": "https://yangzhanlong.github.io/android/ndk/Jni-c-dev.html",
      "content_html": "<h1 id=\"jni导入c库开放流程\" tabindex=\"-1\"> Jni导入c库开放流程</h1>\n",
      "date_published": "2022-09-19T03:10:30.000Z",
      "date_modified": "2022-09-19T03:10:30.000Z",
      "authors": [],
      "tags": [
        "NDK"
      ]
    },
    {
      "title": "Jni静态缓存",
      "url": "https://yangzhanlong.github.io/android/ndk/Jni-cache.html",
      "id": "https://yangzhanlong.github.io/android/ndk/Jni-cache.html",
      "content_html": "<h1 id=\"jni静态缓存\" tabindex=\"-1\"> Jni静态缓存</h1>\n",
      "date_published": "2022-09-19T03:10:30.000Z",
      "date_modified": "2022-09-19T03:10:30.000Z",
      "authors": [],
      "tags": [
        "NDK"
      ]
    },
    {
      "title": "Jni异常处理",
      "url": "https://yangzhanlong.github.io/android/ndk/Jni-exception.html",
      "id": "https://yangzhanlong.github.io/android/ndk/Jni-exception.html",
      "content_html": "<h1 id=\"jni异常处理\" tabindex=\"-1\"> Jni异常处理</h1>\n",
      "date_published": "2022-09-19T03:10:30.000Z",
      "date_modified": "2022-09-19T03:10:30.000Z",
      "authors": [],
      "tags": [
        "NDK"
      ]
    },
    {
      "title": "Jni静态注册与动态注册",
      "url": "https://yangzhanlong.github.io/android/ndk/Jni-register.html",
      "id": "https://yangzhanlong.github.io/android/ndk/Jni-register.html",
      "content_html": "<h1 id=\"jni静态注册与动态注册\" tabindex=\"-1\"> Jni静态注册与动态注册</h1>\n",
      "date_published": "2022-09-19T03:10:30.000Z",
      "date_modified": "2022-09-19T03:10:30.000Z",
      "authors": [],
      "tags": [
        "NDK"
      ]
    },
    {
      "title": "Jni执行原理",
      "url": "https://yangzhanlong.github.io/android/ndk/Jni-run.html",
      "id": "https://yangzhanlong.github.io/android/ndk/Jni-run.html",
      "content_html": "<h1 id=\"jni执行原理\" tabindex=\"-1\"> Jni执行原理</h1>\n",
      "date_published": "2022-09-19T03:10:30.000Z",
      "date_modified": "2022-09-19T03:10:30.000Z",
      "authors": [],
      "tags": [
        "NDK"
      ]
    },
    {
      "title": "使用Jni排序",
      "url": "https://yangzhanlong.github.io/android/ndk/Jni-sort.html",
      "id": "https://yangzhanlong.github.io/android/ndk/Jni-sort.html",
      "content_html": "<h1 id=\"jni-数组排序\" tabindex=\"-1\"> JNI 数组排序</h1>\n<ul>\n<li>MainActivity.kt</li>\n</ul>\n<div><pre><code><span>val</span> arr <span>=</span> <span>intArrayOf</span><span>(</span><span>5</span><span>,</span> <span>6</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>)</span>\nLog<span>.</span><span>i</span><span>(</span><span><span>\"Yang\"</span></span><span>,</span> <span><span>\"排序前：\"</span></span><span>)</span>\n<span>print</span><span>(</span>arr<span>)</span>\n<span>sort</span><span>(</span>arr<span>)</span>\nLog<span>.</span><span>i</span><span>(</span><span><span>\"Yang\"</span></span><span>,</span> <span><span>\"排序后:\"</span></span><span>)</span>\n<span>print</span><span>(</span>arr<span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>\n<li>native-lib.cpp</li>\n</ul>\n<div><pre><code><span>extern</span> <span>\"C\"</span>\nJNIEXPORT <span>void</span> JNICALL\n<span>Java_com_multi_jnistudy_MainActivity_sort</span><span>(</span>JNIEnv <span>*</span>env<span>,</span> jobject thiz<span>,</span> jintArray list<span>)</span> <span>{</span>\n    <span>// list 进行排序</span>\n    <span>// 1. 获取list集合, 使用jint* 接收</span>\n    jint <span>*</span> arr <span>=</span> env<span>-></span><span>GetIntArrayElements</span><span>(</span>list<span>,</span> <span>nullptr</span><span>)</span><span>;</span>\n\n    <span>// 2. 获取数组的长度</span>\n    <span>int</span> length <span>=</span> env<span>-></span><span>GetArrayLength</span><span>(</span>list<span>)</span><span>;</span>\n\n    <span>/**\n     * 3. 调用排序函数\n     *   参数1： void* 数组的首地址\n     *   参数2： 数组的大小长度\n     *   参数3： 数组元素数据类型的大小\n     *   参数4： 数组的一个比较方法指针(Comparable)\n     */</span>\n    <span>qsort</span><span>(</span>arr<span>,</span> length<span>,</span> <span>sizeof</span><span>(</span><span>int</span><span>)</span><span>,</span> <span><span>reinterpret_cast</span><span><span>&lt;</span><span>int</span> <span>(</span><span>*</span><span>)</span><span>(</span><span>const</span> <span>void</span> <span>*</span><span>,</span> <span>const</span> <span>void</span> <span>*</span><span>)</span><span>></span></span></span><span>(</span>compare<span>)</span><span>)</span><span>;</span>\n\n    <span>/**\n     * 4. 执行ReleaseIntArrayElements，同步到java进行数据更新\n     *  参数3：mode说明\n     *  0->既要同步数据给 arr ,又要释放 intArray，会排序\n     *  JNI_COMMIT->会同步数据给 arr ，但是不会释放 intArray，会排序\n     *  JNI_ABORT->不同步数据给 arr ，但是会释放 intArray，所以上层看到就并不会排序\n     */</span>\n     env<span>-></span><span>ReleaseIntArrayElements</span><span>(</span>list<span>,</span> arr<span>,</span> <span>0</span><span>)</span><span>;</span>\n\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code>I/Yang: 排序前：\nI/Yang: 5\nI/Yang: 6\nI/Yang: 8\nI/Yang: 9\nI/Yang: 0\nI/Yang: 1\nI/Yang: 2\nI/Yang: 排序后:\nI/Yang: 0\nI/Yang: 1\nI/Yang: 2\nI/Yang: 5\nI/Yang: 6\nI/Yang: 8\nI/Yang: 9\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>",
      "date_published": "2022-09-19T03:10:30.000Z",
      "date_modified": "2022-09-19T03:10:30.000Z",
      "authors": [],
      "tags": [
        "NDK"
      ]
    },
    {
      "title": "Jni线程",
      "url": "https://yangzhanlong.github.io/android/ndk/Jni-thread.html",
      "id": "https://yangzhanlong.github.io/android/ndk/Jni-thread.html",
      "content_html": "<h1 id=\"jni线程\" tabindex=\"-1\"> Jni线程</h1>\n",
      "date_published": "2022-09-19T03:10:30.000Z",
      "date_modified": "2022-09-19T03:10:30.000Z",
      "authors": [],
      "tags": [
        "NDK"
      ]
    },
    {
      "title": "线程执行原理",
      "url": "https://yangzhanlong.github.io/java/concurrent/thread.html",
      "id": "https://yangzhanlong.github.io/java/concurrent/thread.html",
      "content_html": "<h1 id=\"线程执行原理\" tabindex=\"-1\"> 线程执行原理</h1>\n",
      "date_published": "2022-09-18T13:41:49.000Z",
      "date_modified": "2022-09-20T12:05:15.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Databinding",
      "url": "https://yangzhanlong.github.io/android/framework/jetpack/databinding.html",
      "id": "https://yangzhanlong.github.io/android/framework/jetpack/databinding.html",
      "content_html": "<h1 id=\"databinding\" tabindex=\"-1\"> Databinding</h1>\n",
      "date_published": "2022-09-18T10:12:04.000Z",
      "date_modified": "2022-09-18T10:12:04.000Z",
      "authors": [],
      "tags": [
        "Jetpack"
      ]
    },
    {
      "title": "LifeCycle",
      "url": "https://yangzhanlong.github.io/android/framework/jetpack/lifeCycle.html",
      "id": "https://yangzhanlong.github.io/android/framework/jetpack/lifeCycle.html",
      "content_html": "<h1 id=\"lifecycle\" tabindex=\"-1\"> LifeCycle</h1>\n",
      "date_published": "2022-09-18T10:12:04.000Z",
      "date_modified": "2022-09-18T10:12:04.000Z",
      "authors": [],
      "tags": [
        "Jetpack"
      ]
    },
    {
      "title": "LiveData",
      "url": "https://yangzhanlong.github.io/android/framework/jetpack/liveData.html",
      "id": "https://yangzhanlong.github.io/android/framework/jetpack/liveData.html",
      "content_html": "<h1 id=\"livedata\" tabindex=\"-1\"> LiveData</h1>\n",
      "date_published": "2022-09-18T10:12:04.000Z",
      "date_modified": "2022-09-18T10:12:04.000Z",
      "authors": [],
      "tags": [
        "Jetpack"
      ]
    },
    {
      "title": "ViewModel",
      "url": "https://yangzhanlong.github.io/android/framework/jetpack/viewModel.html",
      "id": "https://yangzhanlong.github.io/android/framework/jetpack/viewModel.html",
      "content_html": "<h1 id=\"viewmodel\" tabindex=\"-1\"> ViewModel</h1>\n",
      "date_published": "2022-09-18T10:12:04.000Z",
      "date_modified": "2022-09-18T10:12:04.000Z",
      "authors": [],
      "tags": [
        "Jetpack"
      ]
    },
    {
      "title": "Handler",
      "url": "https://yangzhanlong.github.io/android/framework/handler.html",
      "id": "https://yangzhanlong.github.io/android/framework/handler.html",
      "content_html": "<h3 id=\"handler\" tabindex=\"-1\"> Handler</h3>\n",
      "date_published": "2022-09-16T10:15:40.000Z",
      "date_modified": "2022-09-16T10:15:40.000Z",
      "authors": [],
      "tags": [
        "Framework"
      ]
    },
    {
      "title": "Android",
      "url": "https://yangzhanlong.github.io/android/",
      "id": "https://yangzhanlong.github.io/android/",
      "content_html": "<h3 id=\"android\" tabindex=\"-1\"> Android</h3>\n<h3 id=\"jetpack\" tabindex=\"-1\"> Jetpack</h3>\n<h3 id=\"kotlin\" tabindex=\"-1\"> Kotlin</h3>\n<ul>\n<li><a href=\"/android/kotlin/kotlin-base.html\">Kotlin基础</a></li>\n</ul>\n<h3 id=\"ndk\" tabindex=\"-1\"> NDK</h3>\n<ul>\n<li><a href=\"/android/ndk/C++-base.html\">C++基础</a></li>\n<li><a href=\"/android/ndk/Jni-base.html\">Jni基础</a></li>\n</ul>\n",
      "date_published": "2022-09-15T12:37:08.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "Android"
      ]
    },
    {
      "title": "Flutter",
      "url": "https://yangzhanlong.github.io/flutter/",
      "id": "https://yangzhanlong.github.io/flutter/",
      "content_html": "<h2 id=\"flutter\" tabindex=\"-1\"> Flutter</h2>\n",
      "date_published": "2022-09-15T12:37:08.000Z",
      "date_modified": "2022-09-20T12:05:15.000Z",
      "authors": [],
      "tags": [
        "Flutter"
      ]
    },
    {
      "title": "音视频",
      "url": "https://yangzhanlong.github.io/video/",
      "id": "https://yangzhanlong.github.io/video/",
      "content_html": "<h2 id=\"音视频\" tabindex=\"-1\"> 音视频</h2>\n",
      "date_published": "2022-09-15T12:37:08.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "音视频"
      ]
    },
    {
      "title": "Java",
      "url": "https://yangzhanlong.github.io/java/",
      "id": "https://yangzhanlong.github.io/java/",
      "content_html": "<h3 id=\"java基础\" tabindex=\"-1\"> Java基础</h3>\n<h3 id=\"动态编程技术\" tabindex=\"-1\"> 动态编程技术</h3>\n<h3 id=\"并发编程\" tabindex=\"-1\"> 并发编程</h3>\n<h3 id=\"io\" tabindex=\"-1\"> IO</h3>\n",
      "date_published": "2022-09-15T12:37:08.000Z",
      "date_modified": "2022-10-04T08:46:29.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "JMM内存模型",
      "url": "https://yangzhanlong.github.io/java/juc/page1.html",
      "id": "https://yangzhanlong.github.io/java/juc/page1.html",
      "content_html": "<h1 id=\"jmm内存模型\" tabindex=\"-1\"> JMM内存模型</h1>\n<h2 id=\"多核并发缓存架构解析\" tabindex=\"-1\"> 多核并发缓存架构解析</h2>\n<p>并发与并行</p>\n<p>并发：单个cpu处理多个线程，每次只处理一个线程</p>\n<p>并行：多个cpu同事处理多个线程，每次同时处理多个线程</p>\n<p>CPU物理内核架构</p>\n<ol>\n<li>每个cpu每次只执行一个线程，基于cpu的时间片轮转机制，单个cpu处理多个线程的时候，看上去是并发的，但其实是串行的</li>\n</ol>\n<p><img src=\"/assets/icon/image_XkaZydKFlR.png\" alt=\"\" loading=\"lazy\"></p>\n<p>多核cpu缓存架构</p>\n<ol>\n<li>\n<p>因为主内存的速度跟不上cpu的速度，因此产生了高速缓存区即缓存</p>\n</li>\n<li>\n<p>当数据在内存产生后，cpu缓存从主内存获取数据，cpu从cpu缓存获取数据，从而产生JMM内存模型</p>\n</li>\n</ol>\n<p><img src=\"/assets/icon/image_bNjUzKBsqr.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://yangzhanlong.github.io/assets/icon/image_XkaZydKFlR.png",
      "date_modified": "2022-10-23T04:35:50.313Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    }
  ]
}